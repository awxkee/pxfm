/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::bessel::i1f::i1f_small;
use crate::bessel::y0f::bessel_fast_log;
use crate::common::f_fmla;
use crate::f_exp;
use crate::polyeval::{f_polyeval8, f_polyeval16};

/// Modified Bessel of the second kind order 1
///
/// Max ULP 0.5
pub fn f_k1f(x: f32) -> f32 {
    if x < 0. {
        return f32::NAN;
    }

    if (x.to_bits() & 0x0007_ffff) == 0 {
        if x == 0. {
            return f32::INFINITY;
        }
        if x.is_infinite() {
            return if x.is_sign_positive() { 0. } else { f32::NAN };
        }
        if x.is_nan() {
            return x + x;
        }
    }

    let xb = x.to_bits();

    if xb >= 0x42cbc779u32 {
        // 101.889595
        return 0.;
    }

    if xb <= 0x3f800000u32 {
        // 1.0
        return k1f_small(x);
    }

    k1f_asympt(x)
}

/**
Series for
f(x) := BesselK(1, x) - Log(x)*BesselI(1, x) - 1/x

(z^17 (-6989 + 2520 EulerGamma - 2520 Log(2)))/4832746593583104000 + (
 z^15 (-1487 + 560 EulerGamma - 560 Log(2)))/3728971137024000 + (
 z^13 (-353 + 140 EulerGamma - 140 Log(2)))/4161798144000 + (
 z^9 (-131 + 60 EulerGamma - 60 Log(2)))/88473600 + (
 z^11 (-71 + 30 EulerGamma - 30 Log(2)))/5308416000 + (
 z^7 (-47 + 24 EulerGamma - 24 Log(2)))/442368 +
 1/64 z^3 (-5 + 4 EulerGamma - 4 Log(2)) + (
 z^5 (-5 + 3 EulerGamma - 3 Log(2)))/1152 +
 1/4 z (-1 + 2 EulerGamma - 2 Log(2))
**/
#[inline]
fn k1f_small(x: f32) -> f32 {
    let dx = x as f64;
    let rcp = 1. / dx;
    let x2 = dx * dx;
    let p = f_polyeval8(
        x2,
        f64::from_bits(0xbfd3b5b6028a83d6),
        f64::from_bits(0xbfb5dadb014541eb),
        f64::from_bits(0xbf7303ae729ff30f),
        f64::from_bits(0xbf1d802af7a5dbc8),
        f64::from_bits(0xbeba291822473f2f),
        f64::from_bits(0xbe4e212a001aa46f),
        f64::from_bits(0xbdd8630abd83ba61),
        f64::from_bits(0xbd5d49398f1e78b6),
    );

    let lg = bessel_fast_log(dx);
    let v_i = i1f_small(x, 1.);
    let z = f_fmla(lg, v_i, rcp);
    let z0 = f_fmla(p, dx, z);
    z0 as f32
}

/**
Generated by Wolfram:
```text
f[x_] := Sqrt[x] Exp[x] BesselK[1, x]
g[z_] := f[1/z]

fReg[s_] := Normal@Series[g[s], {s, 0, 70}]

r = MiniMaxApproximation[g[z], {z, {0.0000000000001, 1}, 15, 2}, WorkingPrecision -> 53]
```
**/
#[inline]
fn k1f_asympt(x: f32) -> f32 {
    let dx = x as f64;
    let recip = 1. / dx;
    let e = f_exp(dx);
    let r_sqrt = dx.sqrt();

    let p0 = f_polyeval16(
        recip,
        f64::from_bits(0x3ff40d931ff6271f),
        f64::from_bits(0x402187c7f226ff9f),
        f64::from_bits(0x402e9a485e838806),
        f64::from_bits(0x400e438cd474f48b),
        f64::from_bits(0xbfe8d47c10aa2cb2),
        f64::from_bits(0x3fdaac389a4f5ee3),
        f64::from_bits(0xbfd4af92b645b7ac),
        f64::from_bits(0x3fd2e3c01e8c6290),
        f64::from_bits(0xbfd1ebf4758a7905),
        f64::from_bits(0x3fd01953c6958378),
        f64::from_bits(0xbfc96d155f4e73d7),
        f64::from_bits(0x3fc08e01d8626cfe),
        f64::from_bits(0xbfb0ac7f601d429c),
        f64::from_bits(0x3f98035819aee877),
        f64::from_bits(0xbf75cc3bea1800c1),
        f64::from_bits(0x3f42a060edb19aec),
    );

    let mut q = f64::from_bits(0x4023b0143991ce3c);
    q = f_fmla(q, recip, f64::from_bits(0x401a7976603ee4ff));
    q = f_fmla(q, recip, f64::from_bits(0x3ff0000000000000));
    let v = p0 / q;
    let pp = v / (e * r_sqrt);
    pp as f32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_k1f() {
        assert_eq!(f_k1f(0.3), 3.055992);
        assert_eq!(f_k1f(1.89), 0.16180483);
        assert_eq!(f_k1f(5.89), 0.0015156545);
        assert_eq!(f_k1f(101.89), 0.);
        assert_eq!(f_k1f(0.), f32::INFINITY);
        assert_eq!(f_k1f(-0.), f32::INFINITY);
        assert!(f_k1f(-0.5).is_nan());
        assert!(f_k1f(f32::NEG_INFINITY).is_nan());
        assert_eq!(f_k1f(f32::INFINITY), 0.);
    }
}
