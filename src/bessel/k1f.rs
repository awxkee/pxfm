/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::bessel::i1f::i1f_small;
use crate::common::f_fmla;
use crate::f_exp;
use crate::logs::simple_fast_log;
use crate::polyeval::{f_estrin_polyeval8, f_polyeval8};

/// Modified Bessel of the second kind order 1
///
/// Max ULP 0.5
pub fn f_k1f(x: f32) -> f32 {
    if x < 0. {
        return f32::NAN;
    }

    if (x.to_bits() & 0x0007_ffff) == 0 {
        if x == 0. {
            return f32::INFINITY;
        }
        if x.is_infinite() {
            return if x.is_sign_positive() { 0. } else { f32::NAN };
        }
        if x.is_nan() {
            return x + x;
        }
    }

    let xb = x.to_bits();

    if xb >= 0x42cbc779u32 {
        // 101.889595
        return 0.;
    }

    if xb <= 0x3f800000u32 {
        // 1.0
        return k1f_small(x);
    }

    k1f_asympt(x)
}

/**
Series for
f(x) := BesselK(1, x) - Log(x)*BesselI(1, x) - 1/x

(z^17 (-6989 + 2520 EulerGamma - 2520 Log(2)))/4832746593583104000 + (
 z^15 (-1487 + 560 EulerGamma - 560 Log(2)))/3728971137024000 + (
 z^13 (-353 + 140 EulerGamma - 140 Log(2)))/4161798144000 + (
 z^9 (-131 + 60 EulerGamma - 60 Log(2)))/88473600 + (
 z^11 (-71 + 30 EulerGamma - 30 Log(2)))/5308416000 + (
 z^7 (-47 + 24 EulerGamma - 24 Log(2)))/442368 +
 1/64 z^3 (-5 + 4 EulerGamma - 4 Log(2)) + (
 z^5 (-5 + 3 EulerGamma - 3 Log(2)))/1152 +
 1/4 z (-1 + 2 EulerGamma - 2 Log(2))
**/
#[inline]
fn k1f_small(x: f32) -> f32 {
    let dx = x as f64;
    let rcp = 1. / dx;
    let x2 = dx * dx;
    let p = f_polyeval8(
        x2,
        f64::from_bits(0xbfd3b5b6028a83d6),
        f64::from_bits(0xbfb5dadb014541eb),
        f64::from_bits(0xbf7303ae729ff30f),
        f64::from_bits(0xbf1d802af7a5dbc8),
        f64::from_bits(0xbeba291822473f2f),
        f64::from_bits(0xbe4e212a001aa46f),
        f64::from_bits(0xbdd8630abd83ba61),
        f64::from_bits(0xbd5d49398f1e78b6),
    );

    let lg = simple_fast_log(dx);
    let v_i = i1f_small(x, 1.);
    let z = f_fmla(lg, v_i, rcp);
    let z0 = f_fmla(p, dx, z);
    z0 as f32
}

/**
Generated by Wolfram Mathematica:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=Sqrt[x] Exp[x] BesselK[1,x]
g[z_]:=f[1/z]
{err, approx}=MiniMaxApproximation[g[z],{z,{0.000000001,1},7,7},WorkingPrecision->60]
poly=Numerator[approx][[1]];
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
poly=Denominator[approx][[1]];
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn k1f_asympt(x: f32) -> f32 {
    let dx = x as f64;
    let recip = 1. / dx;
    let e = f_exp(dx);
    let r_sqrt = dx.sqrt();
    let p_num = f_estrin_polyeval8(
        recip,
        f64::from_bits(0x3ff40d931ff6270d),
        f64::from_bits(0x402d250670ed7a6c),
        f64::from_bits(0x404e517b9b494d38),
        f64::from_bits(0x405cb02b7433a838),
        f64::from_bits(0x405a03e606a1b871),
        f64::from_bits(0x4045c98d4308dbcd),
        f64::from_bits(0x401d115c4ce0540c),
        f64::from_bits(0x3fd4213e72b24b3a),
    );
    let p_den = f_estrin_polyeval8(
        recip,
        f64::from_bits(0x3ff0000000000000),
        f64::from_bits(0x402681096aa3a87d),
        f64::from_bits(0x404623ab8d72ceea),
        f64::from_bits(0x40530af06ea802b2),
        f64::from_bits(0x404d526906fb9cec),
        f64::from_bits(0x403281caca389f1b),
        f64::from_bits(0x3ffdb93996948bb4),
        f64::from_bits(0x3f9a009da07eb989),
    );
    let v = p_num / p_den;
    let pp = v / (e * r_sqrt);
    pp as f32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_k1f() {
        assert_eq!(f_k1f(0.3), 3.055992);
        assert_eq!(f_k1f(1.89), 0.16180483);
        assert_eq!(f_k1f(5.89), 0.0015156545);
        assert_eq!(f_k1f(101.89), 0.);
        assert_eq!(f_k1f(0.), f32::INFINITY);
        assert_eq!(f_k1f(-0.), f32::INFINITY);
        assert!(f_k1f(-0.5).is_nan());
        assert!(f_k1f(f32::NEG_INFINITY).is_nan());
        assert_eq!(f_k1f(f32::INFINITY), 0.);
    }
}
