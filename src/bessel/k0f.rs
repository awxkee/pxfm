/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::bessel::i0f::i0f_small;
use crate::bessel::y0f::bessel_fast_log;
use crate::common::f_fmla;
use crate::f_exp;
use crate::polyeval::{f_polyeval5, f_polyeval8, f_polyeval10, f_polyeval11, f_polyeval22};

/// Modified bessel of the second kind order 0
///
/// Max ULP 0.5
pub fn f_k0f(x: f32) -> f32 {
    if x < 0. {
        return f32::NAN;
    }

    if (x.to_bits() & 0x0007_ffff) == 0 {
        if x == 0. {
            return f32::INFINITY;
        }
        if x.is_infinite() {
            return if x.is_sign_positive() { 0. } else { f32::NAN };
        }
        if x.is_nan() {
            return x + x;
        }
    }

    let xb = x.to_bits();

    if xb >= 0x42cbc4fbu32 {
        // 101.88473
        return 0.;
    }

    if xb <= 0x3a83126fu32 {
        // 1e-3
        return k0f_tiny(x);
    } else if xb <= 0x3de147aeu32 {
        // 0.11
        return k0f_up_to_0p11(x);
    } else if xb <= 0x3f000000u32 {
        // 0.5
        return k0f_0p11_up_to_0p5(x);
    } else if xb <= 0x3f800000u32 {
        return k0f_0p5_up_to_1p0(x);
    }

    k0f_asympt(x)
}

/**
K0(x) + log(x) * I0(x) = P(x^2)
hence
K0(x) = P(x^2) - log(x)*I0(x)

Polynomial generated by Sollya for interval [0.11; 0.5].

See ./notes/bessel_sollya/bessel_k0f_small.sollya
**/
#[inline]
fn k0f_0p5_up_to_1p0(x: f32) -> f32 {
    let v_log = bessel_fast_log(x as f64);
    let i0 = i0f_small(x);

    let dx = x as f64;

    let p = f_polyeval11(
        dx,
        f64::from_bits(0x3fbdadb015c26656),
        f64::from_bits(0xbe360d823aca4f15),
        f64::from_bits(0x3fd1dadb27967175),
        f64::from_bits(0xbe83cd01287a9faf),
        f64::from_bits(0x3f99daf607667713),
        f64::from_bits(0xbea9874bf4595c50),
        f64::from_bits(0x3f4bc18cb0ce48f7),
        f64::from_bits(0xbeafac738a8d87a8),
        f64::from_bits(0x3ef044060b1d9c60),
        f64::from_bits(0xbe8fd809a600fcfb),
        f64::from_bits(0x3e8c2f303c482ff2),
    );
    let c = f_fmla(-i0, v_log, p);
    c as f32
}

/**
K0(x) + log(x) * I0(x) = P(x^2)
hence
K0(x) = P(x^2) - log(x)*I0(x)

Polynomial generated by Sollya for interval [0.11; 0.5].

See ./notes/bessel_sollya/bessel_k0f_small.sollya
**/
#[inline]
fn k0f_0p11_up_to_0p5(x: f32) -> f32 {
    let v_log = bessel_fast_log(x as f64);
    let i0 = i0f_small(x);

    let dx = x as f64;

    let p = f_polyeval10(
        dx,
        f64::from_bits(0x3fbdadb01453bd69),
        f64::from_bits(0x3db0315ff2b1ea82),
        f64::from_bits(0x3fd1dadb00fa3cde),
        f64::from_bits(0x3e28e496ead7dd76),
        f64::from_bits(0x3f99dad9b18a9d5c),
        f64::from_bits(0x3e778099952a8b73),
        f64::from_bits(0x3f4bb6d6faee2458),
        f64::from_bits(0x3ea1d4e2bf66be89),
        f64::from_bits(0x3eedd9283073fb69),
        f64::from_bits(0x3ea0ec64f1933b19),
    );
    let c = f_fmla(-i0, v_log, p);
    c as f32
}

/**
K0(x) + log(x) * I0(x) = P(x^2)
hence
K0(x) = P(x^2) - log(x)*I0(x)

Polynomial generated by Sollya for interval [1e-3; 0.3].

See ./notes/bessel_sollya/bessel_k0f_small.sollya
**/
#[inline]
fn k0f_up_to_0p11(x: f32) -> f32 {
    let v_log = bessel_fast_log(x as f64);
    let i0 = i0f_small(x);

    let dx = x as f64;

    let p = f_polyeval8(
        dx,
        f64::from_bits(0x3fbdadb014541eb0),
        f64::from_bits(0x3d112b8752a0b0f2),
        f64::from_bits(0x3fd1dadb01448f1f),
        f64::from_bits(0x3de7dccb04d8bee3),
        f64::from_bits(0x3f99dada9a7840aa),
        f64::from_bits(0x3e7e711f22bac6cc),
        f64::from_bits(0x3f4baf000a202a2e),
        f64::from_bits(0x3edbcac04b3fec4c),
    );
    let c = f_fmla(-i0, v_log, p);
    c as f32
}

/**
K0(x) + log(x) * I0(x) = P(x^2)
hence
K0(x) = P(x^2) - log(x)*I0(x)

Polynomial generated by Sollya for interval [1e-20; 1e-3].

See ./notes/bessel_sollya/bessel_k0f_small.sollya
**/
#[inline]
fn k0f_tiny(x: f32) -> f32 {
    let v_log = bessel_fast_log(x as f64);
    let i0 = i0f_small(x);

    let dx = x as f64;

    let p = f_polyeval5(
        dx,
        f64::from_bits(0x3fbdadb014541eb2),
        f64::from_bits(0xbc111c128d10d8d0),
        f64::from_bits(0x3fd1dadb0145420a),
        f64::from_bits(0xbd925f9a609b5eec),
        f64::from_bits(0x3f99dadb3e20e3f7),
    );
    let c = f_fmla(-i0, v_log, p);
    c as f32
}

/**
Generated in Wolfram

Computes sqrt(x)*exp(x)*K0(x)=Pn(1/x)/Qm(1/x)
hence
K0(x) = Pn(1/x)/Qm(1/x) / (sqrt(x) * exp(x))

```text
<< FunctionApproximations`
f[x_] := Sqrt[x] Exp[x] BesselK[0, x]
g[z_] := f[1/z]
r = MiniMaxApproximation[g[z], {z, {0.0000000000001, 1}, 21, 2},
  WorkingPrecision -> 53]
```
**/
#[inline]
fn k0f_asympt(x: f32) -> f32 {
    let dx = x as f64;
    let recip = 1. / dx;
    let e = f_exp(dx);
    let r_sqrt = dx.sqrt();

    let p0 = f_polyeval22(
        recip,
        f64::from_bits(0x3ff40d931ff62706),
        f64::from_bits(0x402545577f89b7fa),
        f64::from_bits(0x40342cb01b94ebc1),
        f64::from_bits(0xc000196914a4cdf1),
        f64::from_bits(0x3feb6f0b0d983efb),
        f64::from_bits(0xbfe49dc4f2e4b38e),
        f64::from_bits(0x3fe5750c81cc8d9e),
        f64::from_bits(0xbfeb5512eef568e9),
        f64::from_bits(0x3ff3953ebfd446e5),
        f64::from_bits(0xbffd842ee55c4c37),
        f64::from_bits(0x40061bf66a0ea028),
        f64::from_bits(0xc00f6470df511466),
        f64::from_bits(0x40144f951beeb20d),
        f64::from_bits(0xc01730a192cfd113),
        f64::from_bits(0x4016b914aeec0474),
        f64::from_bits(0xc0129f4059922709),
        f64::from_bits(0x4008da0c3b17090c),
        f64::from_bits(0xbffa28d54bd9faab),
        f64::from_bits(0x3fe4d03efb7c3bb6),
        f64::from_bits(0xbfc774cc73afe965),
        f64::from_bits(0x3fa0a53ee3f5b71c),
        f64::from_bits(0xbf6654d8e4751229),
    );

    let mut q = f64::from_bits(0x40311a5f3401f214);
    q = f_fmla(q, recip, f64::from_bits(0x402138c10f79def4));
    q = f_fmla(q, recip, f64::from_bits(0x3ff0000000000000));
    let v = p0 / q;
    let pp = v / (e * r_sqrt);
    pp as f32
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_k0f() {
        assert_eq!(f_k0f(2.034804e-5), 10.918458);
        assert_eq!(f_k0f(0.010260499), 4.695535);
        assert_eq!(f_k0f(0.3260499), 1.2965646);
        assert_eq!(f_k0f(0.72341), 0.636511734);
        assert_eq!(f_k0f(0.), f32::INFINITY);
        assert_eq!(f_k0f(-0.), f32::INFINITY);
        assert!(f_k0f(-0.5).is_nan());
        assert!(f_k0f(f32::NEG_INFINITY).is_nan());
        assert_eq!(f_k0f(f32::INFINITY), 0.);
    }
}
