/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::common::{dd_fmla, f_fmla};
use crate::double_double::DoubleDouble;
use crate::dyadic_float::{DyadicFloat128, DyadicSign};
use crate::exponents::{EXP_REDUCE_T0, EXP_REDUCE_T1, rational128_exp};
use crate::horner::f_horner_polyeval11;

/// Modified Bessel of the first kind of order 0
///
/// Max ULP 0.5
pub fn f_i0(x: f64) -> f64 {
    let xb = x.to_bits() & 0x7fff_ffff_ffff_ffff;

    if !x.is_normal() {
        if x == 0. {
            return 1.;
        }
        if x.is_infinite() {
            return f64::INFINITY;
        }
        if x.is_nan() {
            return f64::NAN;
        }
    }

    if xb > 0x40864fe5304e83e4u64 {
        // 713.9869085439682
        return f64::INFINITY;
    }

    if xb <= 0x400ccccccccccccdu64 {
        return i0_0_to_3p6_exec(f64::from_bits(xb));
    } else if xb <= 0x401e000000000000u64 {
        return i3p6_to_7p5(f64::from_bits(xb));
    } else if xb <= 0x4023000000000000u64 {
        // 9.5
        return i0_7p5_to_9p5(f64::from_bits(xb));
    }

    i0_asympt(f64::from_bits(xb))
}

/**
Computes I0 on interval [-7.5; -3.6], [3.6; 7.5]
**/
#[inline]
fn i3p6_to_7p5(x: f64) -> f64 {
    let r = i0_0_to_3p6_dd(x);

    const ERR: f64 = f64::from_bits(0x3c3ee8f34dd80440);

    let err = f_fmla(r.hi, f64::from_bits(0x3a08406003b2ae42), ERR);

    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub != lb {
        return eval_small_hard_3p6_to_7p5(x);
    }
    r.to_f64()
}

/**
Computes I0 on interval [-7.5; -3.6], [3.6; 7.5]
as rational approximation I0 = 1 + (x/2)^2 * Pn((x/2)^2)/Qm((x/2)^2))
where n = 16 and m = 0.

Relative error on interval 2^-(105.71).

Generated by SageMath:
```python
from sage.all import *
from mpmath import mp, besseli, taylor

mp.prec = 450

def shifted_i0(x):
    return besseli(0, x) - mp.mpf(1)

terms = 100
from mpmath import taylor
coeffs = taylor(shifted_i0, 0, terms)

R = PolynomialRing(RealField(450), 'y')
y = R.gen()
f = R(0)

for n in range(2, terms, 2):
    k = n // 2
    c = RealField(450)(coeffs[n])
    if n >= 1:
        f += R(c) * y**(k-1) * (4**k)
    else:
        f += R(c) * y**(k-1) * (4**k)

# See the series
print(f)
```
See ./notes/bessel_i0.ipynb for generation

Next step is poly generation in Sollya see ./notes/bessel_sollya/bessel_i0_small.sollya for generation
**/
#[inline]
fn i0_0_to_3p6_dd(x: f64) -> DoubleDouble {
    let dx = x;
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(dx, dx), ONE_OVER_4);
    const C_HI: [u64; 11] = [
        0x3d35601885e63fac,
        0x3cc69ca9cf3b58eb,
        0x3c54197a7f54eb39,
        0x3bde72559462814f,
        0x3b63e22d79919a4b,
        0x3ae69f7cccd0fd97,
        0x3a669f8eebc21ada,
        0x39e40920f41b8490,
        0x395fc34bd48c842f,
        0x38d5afe40c297100,
        0x385235b4bae18dd0,
    ];

    let r = f_horner_polyeval11(
        eval_x.to_f64(),
        f64::from_bits(C_HI[0]),
        f64::from_bits(C_HI[1]),
        f64::from_bits(C_HI[2]),
        f64::from_bits(C_HI[3]),
        f64::from_bits(C_HI[4]),
        f64::from_bits(C_HI[5]),
        f64::from_bits(C_HI[6]),
        f64::from_bits(C_HI[7]),
        f64::from_bits(C_HI[8]),
        f64::from_bits(C_HI[9]),
        f64::from_bits(C_HI[10]),
    );

    const C: [(u64, u64); 9] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3aa39fd120000000, 0x3fd0000000000000),
        (0x3c3c71c6f85e8f3e, 0x3f9c71c71c71c71c),
        (0x3bfc71cb05d4728c, 0x3f5c71c71c71c71c),
        (0x3b52234fc899bd00, 0x3f123456789abcdf),
        (0xbb4b54d084479968, 0x3ec02e85c0898b71),
        (0xbb06f32cc666cec1, 0x3e6522a43f65486a),
        (0x3a8179e1fd68e9f0, 0x3e0522a43f65486a),
        (0x3a467a15395c5c36, 0x3da0b313289be0af),
    ];

    let mut p = DoubleDouble::mul_f64_add(eval_x, r, DoubleDouble::from_bit_pair(C[8]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[7]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[6]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[5]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[4]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[3]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[2]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[1]));
    p = DoubleDouble::mul_add_f64(eval_x, p, f64::from_bits(C[0].1));

    let z = DoubleDouble::quick_mult(p, eval_x);

    DoubleDouble::full_add_f64(z, 1.)
}

#[cold]
#[inline(never)]
fn eval_small_hard_3p6_to_7p5(x: f64) -> f64 {
    // See ./notes/bessel_sollya/bessel_i0_small_rational.sollya
    static C: [DyadicFloat128; 21] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -127,
            mantissa: 0x80000000_00000000_0000004e_31bffd08_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -130,
            mantissa: 0xffffffff_ffffffff_fffff617_e5690b92_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe38e38e3_8e38e38e_38e426b2_d0ca3408_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -137,
            mantissa: 0xe38e38e3_8e38e38e_38d7fbda_568ad104_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -141,
            mantissa: 0x91a2b3c4_d5e6f809_1aca6c9f_f464540c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -146,
            mantissa: 0x81742e04_4c5b8724_7c2842de_0eca2c4a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -152,
            mantissa: 0xa91521fb_2a434d41_05c40297_e907574a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -158,
            mantissa: 0xa91521fb_2a434d15_23afa32e_ed7ac73e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -164,
            mantissa: 0x85989944_df05c86b_64270ef5_543b316a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -171,
            mantissa: 0xab00c42f_31f26eaf_cd745bd6_2e0ef9ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -178,
            mantissa: 0xb4e54e79_dc082ec5_4d1321a1_df8664ec_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -185,
            mantissa: 0xa0cbd3fa_8962023f_64172213_0435e6ac_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -193,
            mantissa: 0xf392aca7_a4b8283e_3c607d74_10c95a40_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -200,
            mantissa: 0x9f116b84_43e00084_0b595646_94fc0b2e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -208,
            mantissa: 0xb4fbed99_1bc7c86a_abd70d3e_3f23060e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -216,
            mantissa: 0xb4fbe5d8_039415a8_dd11f34f_63bffa26_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -224,
            mantissa: 0xa051f028_67ca2964_021e6d9e_1bcbd9bc_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -233,
            mantissa: 0xfd49af7a_f395c504_70f37e03_b086d2ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -241,
            mantissa: 0xb4369521_9ef1c21f_83b4f7c8_20a81126_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -250,
            mantissa: 0xdde7c5db_c06182e7_ff123ae2_af7cb5ae_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -258,
            mantissa: 0xa981fcef_953ccc14_3e27285a_89ea06cc_u128,
        },
    ];

    const ONES: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Pos,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let dx = DyadicFloat128::new_from_f64(x);
    let mut eval_x = dx * dx;
    eval_x.exponent -= 2; // div by 4

    let mut p = C[20];
    for i in (0..20).rev() {
        p = eval_x * p + C[i];
    }
    let z = p * eval_x;
    (z + ONES).fast_as_f64()
}

#[inline]
pub(crate) fn i0_0_to_3p6_exec(x: f64) -> f64 {
    let r = i0_0_to_3p6_dd(x);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3be0000000000000),
        f64::from_bits(0x3970000000000000),
    );
    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub == lb {
        return r.to_f64();
    }
    i0_0_to_3p6_hard(x)
}

#[cold]
#[inline(never)]
fn i0_0_to_3p6_hard(x: f64) -> f64 {
    // See ./notes/bessel_sollya/bessel_i0_small_rational128.sollya
    let mut dx = DyadicFloat128::new_from_f64(x);
    dx = dx * dx;
    dx.exponent -= 2; // * 0.25
    static P: [DyadicFloat128; 20] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -127,
            mantissa: 0x80000000_00000000_00000000_00000000_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0x80000000_00000000_00000000_00000008_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe38e38e3_8e38e38e_38e38e38_e38e22c4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -137,
            mantissa: 0xe38e38e3_8e38e38e_38e38e38_e3a43412_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -141,
            mantissa: 0x91a2b3c4_d5e6f809_1a2b3c4d_5332b504_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -146,
            mantissa: 0x81742e04_4c5b8724_8909fcbd_7c995b8a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -152,
            mantissa: 0xa91521fb_2a434d3f_649f4edc_3e07de2a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -158,
            mantissa: 0xa91521fb_2a434d3f_64a291ec_56f26dc6_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -164,
            mantissa: 0x85989944_df05c4ef_b6731346_f776e9ba_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -171,
            mantissa: 0xab00c42f_31f2e79a_15232ee1_4ce32720_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -178,
            mantissa: 0xb4e54e79_dbfa9bbc_4a391754_f8b1e038_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -185,
            mantissa: 0xa0cbd3fa_8aa605f4_ed9568b3_c02893ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -193,
            mantissa: 0xf392aca7_7281aa35_fccc9f5c_d105e062_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -200,
            mantissa: 0x9f116b87_7ea9f5fd_e26b0cc9_056b7fbe_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -208,
            mantissa: 0xb4fbed40_e04899a4_0b62c76f_aad78b72_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -216,
            mantissa: 0xb4fbedb2_7b0d92fa_2b9dee5e_8f241966_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -224,
            mantissa: 0xa05157e0_217cd73b_3a7d1681_7d9e923c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -233,
            mantissa: 0xfd5dfb7b_c3d1fe5b_a3491aa5_bc061ec0_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -241,
            mantissa: 0xb306b987_18677d4c_f4c4eca9_5d30e83a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -250,
            mantissa: 0xf94742a0_7060713c_15a39160_c3b15b1e_u128,
        },
    ];
    const ONE: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Pos,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };

    let mut p = P[19];
    for i in (0..19).rev() {
        p = dx * p + P[i];
    }
    let z = p * dx;
    (z + ONE).fast_as_f64()
}

/**
Mid-interval [7.5;9.5] generated by Wolfram:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=Sqrt[x] Exp[-x] BesselI[0,x]
g[z_]:=f[1/z]
{err, approx}=MiniMaxApproximation[g[z],{z,{1/9.5,1/7.5},11,11},WorkingPrecision->120]
num=Numerator[approx][[1]];
den=Denominator[approx][[1]];
poly=den;
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn i0_7p5_to_9p5(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_quick_recip(x);

    const P: [(u64, u64); 12] = [
        (0x3c778e3de1f76f48, 0x3fd988450531281b),
        (0xbcb572f6149f389e, 0xc01a786676fb4d3a),
        (0x3cf2f373365347ed, 0x405c0e8405fdb642),
        (0x3d276a94c8f1e627, 0xc0885e4718dfb761),
        (0x3d569f8a993434e2, 0x40b756d52d5fa90c),
        (0xbd6f953f7dd1a223, 0xc0c8818365c47790),
        (0xbd74247967fbf7b2, 0x40e8cf89daf87353),
        (0x3db449add7abb056, 0x41145d3c2d96d159),
        (0xbdc5cc822b71f891, 0xc123694c58fd039b),
        (0x3da2047ac1a6fba8, 0x415462e630bf3e7e),
        (0xbdc2f2c06eda6a95, 0xc14c6984ebdd6792),
        (0xbdf51fa85dafeca5, 0x4166a437c202d27b),
    ];

    let mut p_num = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(P[11]),
        DoubleDouble::from_bit_pair(P[10]),
    );
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[9]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[8]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[7]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[6]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[0]));

    const Q: [(u64, u64); 12] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3cde08e4cbf324d1, 0xc030b67bd69af0ca),
        (0x3cec5e4ee7e77024, 0x4071b54c0f58409c),
        (0xbd340e1131739e2f, 0xc09f140a738b14b3),
        (0x3d607673189d6644, 0x40cdb44bd822add2),
        (0xbd7793a4f1dd74d1, 0xc0e03fe2689b802d),
        (0xbd8415501228a87e, 0x410009beafea72cc),
        (0x3dcecdac2702661f, 0x4128c2073da9a447),
        (0xbdd8386404f3dec5, 0xc1389ec7d7186bf4),
        (0xbe06eb53a3e86436, 0x4168b7a2dc85ed0b),
        (0x3e098e2cefaf8299, 0xc1604f8cf34af02c),
        (0x3e1a5e496b547001, 0x41776b1e0153d1e9),
    ];

    let mut p_den = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(Q[11]),
        DoubleDouble::from_bit_pair(Q[10]),
    );
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[9]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[8]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[7]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[6]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[5]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(recip, p_den, f64::from_bits(0x3ff0000000000000));

    let z = DoubleDouble::div(p_num, p_den);

    let e = i0_exp(dx);
    let r_sqrt = DoubleDouble::from_rsqrt_fast(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt, e);

    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bc0000000000000),
        f64::from_bits(0x392bdb8cdadbe111),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_7p5_to_9p5_hard(x);
    }
    r.to_f64()
}

/**
Mid-interval [7.5;9.5] generated by Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/9.5, 1/7.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya/bessel_i0_mid_interval.sollya
**/
#[cold]
#[inline(never)]
fn i0_7p5_to_9p5_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 30] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc40e2dc_d2884163_7a151c1d_91d7acce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xd60fd904_ed8e723b_043ebb0a_c84e6b71_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -129,
            mantissa: 0x826d75fb_ead03ab6_3812b81a_82ae9e16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xab464d96_4d8d2351_036d2731_61f33b19_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -117,
            mantissa: 0x912d7ff1_b51e07c4_674c4595_6df64222_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -112,
            mantissa: 0xbc8a9db2_47fdd5a1_8b7c144f_5e8c2fe1_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -107,
            mantissa: 0xc2b4b2e7_c4166e86_7143b733_7bc1886e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -102,
            mantissa: 0xa41c2372_9a91cd00_ea6ade71_7d2f42a8_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -98,
            mantissa: 0xe5f8aaa7_f2c866b6_ce66dbb4_dd4230ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -93,
            mantissa: 0x87bff342_b4fe58f7_139c6679_a2189ccd_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -89,
            mantissa: 0x885ca780_fe663093_3fa35150_4f9f9dbe_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -86,
            mantissa: 0xead2af4f_e2c4335b_b94f0344_3738d42f_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -82,
            mantissa: 0xae41260b_140008bd_6060f8ac_8c50d2b2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -79,
            mantissa: 0xdfbff6f7_8ae5df08_d19a1b22_5e4d2ae7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -76,
            mantissa: 0xf932115e_b49672b5_56f3bdcc_1249f108_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf10822de_47e2d8bd_87b0dbf5_20bd8bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -70,
            mantissa: 0xca7d3a1e_aa7d6fd0_5d3851b7_c06b6141_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -67,
            mantissa: 0x939429b8_bf029a93_dbd23d8f_81b18f78_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -65,
            mantissa: 0xba296c69_4f459398_321558f5_70d37365_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -63,
            mantissa: 0xca6906bd_16f298b3_7c715800_0e8b932a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -61,
            mantissa: 0xbc981d79_aa00aff0_822f256e_2508cd20_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0x95610c80_7e0e934d_37e8fd8e_26a91bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -58,
            mantissa: 0xc6faee68_2d02a10b_71307961_4c7089da_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -57,
            mantissa: 0xdb99648b_ea5faf8b_fa2b22cf_23519879_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -56,
            mantissa: 0xc4bfb9fc_868c1729_555e5bd7_d8d560ff_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -55,
            mantissa: 0x8b0aecb8_713e1619_d2c04466_79285901_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -55,
            mantissa: 0x9488128f_4a0b453e_b756f985_a5535449_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -56,
            mantissa: 0xdffd122b_4227df24_0fea2700_a9463ad3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0xd268f940_a7ee25f1_eb82b522_aa3bcb9e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0xb63002c8_6697c63e_625f0d0f_da7c5ab1_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let mut z = P[29];
    for i in (0..29).rev() {
        z = recip * z + P[i];
    }
    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[inline(always)]
fn exp_poly(z: f64) -> DoubleDouble {
    /* The following is a degree-4 polynomial generated by Sollya for exp(x)
    over [-2^-12.905,2^-12.905]
    with absolute error < 2^-74.34 (see sollya/Q_1.sollya). */
    const Q_1: [u64; 5] = [
        0x3ff0000000000000,
        0x3ff0000000000000,
        0x3fe0000000000000,
        0x3fc5555555997996,
        0x3fa5555555849d8d,
    ];
    let mut q = dd_fmla(f64::from_bits(Q_1[4]), z, f64::from_bits(Q_1[3]));
    q = dd_fmla(q, z, f64::from_bits(Q_1[2]));
    let h0 = dd_fmla(q, z, f64::from_bits(Q_1[1]));

    let v1 = DoubleDouble::from_exact_mult(z, h0);
    DoubleDouble::f64_add(f64::from_bits(Q_1[0]), v1)
}

#[inline]
pub(crate) fn i0_exp(r: f64) -> DoubleDouble {
    const INVLOG2: f64 = f64::from_bits(0x40b71547652b82fe);

    let k = (r * INVLOG2).round();

    const L2: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0x3d0718432a1b0e26),
        f64::from_bits(0x3f262e42ff000000),
    );

    let zh = f_fmla(L2.lo, k, f_fmla(-L2.hi, k, r));

    let bk = k as i64;
    let mk = (bk >> 12) + 0x3ff;
    let i2 = (bk >> 6) & 0x3f;
    let i1 = bk & 0x3f;

    let t0 = DoubleDouble::from_bit_pair(EXP_REDUCE_T0[i2 as usize]);
    let t1 = DoubleDouble::from_bit_pair(EXP_REDUCE_T1[i1 as usize]);
    let mut de = DoubleDouble::quick_mult(t1, t0);
    let q = exp_poly(zh);
    de = DoubleDouble::quick_mult(de, q);

    let mut du = (mk as u64).wrapping_shl(52);
    du = f64::from_bits(du).to_bits();
    DoubleDouble::quick_mult_f64(de, f64::from_bits(du))
}

/**
Generated in Wolfram:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=Sqrt[x] Exp[-x] BesselI[0,x]
g[z_]:=f[1/z]
{err, approx}=MiniMaxApproximation[g[z],{z,{1/709.3,1/9.5},10,10},WorkingPrecision->120]
num=Numerator[approx][[1]];
den=Denominator[approx][[1]];
poly=num;
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn i0_asympt(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_quick_recip(x);
    const P: [(u64, u64); 12] = [
        (0xbc7ca19c5d824c54, 0x3fd9884533d43651),
        (0x3cca32eb734e010e, 0xc03b7ca35caf42eb),
        (0x3d03af8238d6f25e, 0x408b92cfcaa7070f),
        (0xbd7a8ff7fdebed70, 0xc0d0a3be432cce93),
        (0xbdababdb579bb076, 0x410a77dc51f1804d),
        (0x3dc5e4e3c972832a, 0xc13cb0be2f74839c),
        (0x3e01076f9b102e38, 0x41653b064cc61661),
        (0xbe2157e700d445f4, 0xc184e1b076927460),
        (0xbdfa4577156dde56, 0x41999e9653f9dc5f),
        (0xbe47aa238a739ffe, 0xc1a130f6ded40c00),
        (0xbe331b560b6fbf4a, 0x419317f11e674cae),
        (0xbe0765596077d1e3, 0xc16024404db59d3f),
    ];

    let mut p_num = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(P[11]),
        DoubleDouble::from_bit_pair(P[10]),
    );
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[9]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[8]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[7]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[6]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[0]));

    const Q: [(u64, u64); 12] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0xbcf687703e843d07, 0xc051418f1c4dd0b9),
        (0x3d468ab92cb87a0b, 0x40a15891d823e48d),
        (0x3d8bfc17e5183376, 0xc0e4fce40dd82796),
        (0xbdccbbcc2ecf8d4c, 0x4120beef869c61ec),
        (0xbdf42170b4d5d150, 0xc1523ad18834a7ed),
        (0xbe0eaa32f405afd4, 0x417b24ec57a8f480),
        (0x3e3ec900705e7252, 0xc19af2a91d23d62e),
        (0x3e3e220e274fa46b, 0x41b0cb905cc99ff5),
        (0xbe46c6c61dee11f6, 0xc1b7452e50518520),
        (0x3e3ed0fc063187bf, 0x41ac1772d1749896),
        (0xbe11c578f04f4be1, 0xc180feb5b2ca47cb),
    ];

    let mut p_den = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(Q[11]),
        DoubleDouble::from_bit_pair(Q[10]),
    );
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[9]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[8]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[7]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[6]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[5]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(recip, p_den, f64::from_bits(0x3ff0000000000000));

    let z = DoubleDouble::div(p_num, p_den);

    let mut e = i0_exp(dx * 0.5);
    e = DoubleDouble::from_exact_add(e.hi, e.lo);
    let r_sqrt = DoubleDouble::from_rsqrt_fast(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt * e, e);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bc8406003b2ae42),
        f64::from_bits(0x3b8ee8f34dd80440),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_asympt_hard(x);
    }
    lb
}

#[inline]
pub(crate) fn bessel_rsqrt_hard(x: f64, recip: DyadicFloat128) -> DyadicFloat128 {
    let r = DyadicFloat128::new_from_f64(x.sqrt()) * recip;
    let fx = DyadicFloat128::new_from_f64(x);
    let rx = r * fx;
    let drx = r * fx - rx;
    const M_ONE: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Neg,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let h = r * rx + M_ONE + r * drx;
    let mut ddr = r;
    ddr.exponent -= 1; // ddr * 0.5
    let dr = ddr * h;
    r - dr
}

#[cold]
#[inline(never)]
fn i0_asympt_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 39] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc42299e_a1b28468_964d7809_1e153b28_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xcc42299e_a1b27b1d_6d33e22d_42af57ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe5ca6ed2_764f20df_18f5f2d7_2a7e8b04_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xef5d88c4_98654148_67cec9f3_2032427e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xb7439e21_53e1d4f0_aa491618_ca48a4a4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -131,
            mantissa: 0xb98cf60a_158f684f_5c72c4cd_2818c7b3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -130,
            mantissa: 0xea82ecdf_b9479960_ac88fc5b_8f9e0a7d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -128,
            mantissa: 0x8c273635_ca1c900e_98f6c71a_826d5977_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xe06125df_765ba22f_cebf8c65_52b8d48c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -116,
            mantissa: 0xe89603d0_1581f464_f20bc333_7d71a36e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -109,
            mantissa: 0xd91fbda9_3c0ebc5e_a2b78b16_9c4b2560_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -102,
            mantissa: 0xa78e0095_bfa0f966_97da5569_f60f8aa4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -96,
            mantissa: 0xd8b22ab2_a8dde015_5622fed3_9a60f561_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -90,
            mantissa: 0xece6470e_66c24229_037f3c2f_416c833a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -84,
            mantissa: 0xdc8e3464_a24e8206_dbfe3ba9_11703acf_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -78,
            mantissa: 0xaff3b9fb_40dda7ac_89cf17a8_bea6e2f2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf1cb3f14_3e89cd6a_2dc6167a_ce504577_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -67,
            mantissa: 0x8fb0d81a_a3692efd_189ec80d_0aae5d37_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -62,
            mantissa: 0x94347114_15198a4d_6317caec_2faff732_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0x84ff7613_714a7551_09223bb6_1f49312d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -53,
            mantissa: 0xd0145383_8c852144_cfeeeea9_b4baa304_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -48,
            mantissa: 0x8e109265_a66393e8_a33646c5_85d0ba16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -44,
            mantissa: 0xa9671293_1a0d6041_51cc9bc0_ad2461df_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -40,
            mantissa: 0xb061afcc_6f4d05d2_b926d5d9_b47c0172_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -36,
            mantissa: 0xa039d17c_4d55483a_2b39d90e_d8e03de3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -33,
            mantissa: 0xfd92ae02_a0366717_bd1331a2_19b3916c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -29,
            mantissa: 0xae5bfdae_50bb66d4_2ac34bea_4ba9b128_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -26,
            mantissa: 0xcfa58c78_a4167a6e_97ae7616_f0553da3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -23,
            mantissa: 0xd52793cf_74ac26bd_d5800287_97bb5656_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -20,
            mantissa: 0xbb737ea1_59a1ab1b_203d09f3_53293bfc_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -17,
            mantissa: 0x8c172597_97519909_d450bc5e_f7346a1a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -15,
            mantissa: 0xb01241b7_f476dded_68756bd7_93311623_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -13,
            mantissa: 0xb77a8654_a8c8cfb6_86fbd12f_20aa21c6_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -11,
            mantissa: 0x9b85f327_836de71e_0a95c587_df73dd47_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xd0c72b4a_81123937_16778b17_feaab3f7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -9,
            mantissa: 0xd54b34b5_08f7c7a1_53a5d591_64f5be90_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -8,
            mantissa: 0x9b9b8af7_85bf3bf1_7158ff4f_6d389faa_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -8,
            mantissa: 0x90351b61_b023a397_22d92dce_f0326527_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xfeb8c9fd_06312e7b_7e5a02a3_0147801d_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let mut z = P[38];
    for i in (0..38).rev() {
        z = recip * z + P[i];
    }

    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_i0() {
        assert!(f_i0(f64::NAN).is_nan());
        assert_eq!(f_i0(f64::INFINITY), f64::INFINITY);
        assert_eq!(f_i0(f64::NEG_INFINITY), f64::INFINITY);
        assert_eq!(f_i0(7.500000000788034), 268.1613117118702);
        assert_eq!(f_i0(715.), f64::INFINITY);
        assert_eq!(f_i0(12.), 18948.925349296307);
        assert_eq!(f_i0(16.), 893446.227920105);
        assert_eq!(f_i0(18.432), 9463892.87209841);
        assert_eq!(f_i0(26.432), 23507752424.350075);
        assert_eq!(f_i0(0.2), 1.010025027795146);
        assert_eq!(f_i0(7.5), 268.16131151518937);
        assert_eq!(f_i0(-1.5), 1.646723189772891);
    }
}
