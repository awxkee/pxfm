/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::common::{dd_fmla, f_fmla};
use crate::double_double::DoubleDouble;
use crate::dyadic_float::{DyadicFloat128, DyadicSign};
use crate::exponents::{EXP_REDUCE_T0, EXP_REDUCE_T1, rational128_exp};
use crate::polyeval::{f_estrin_polyeval5, f_polyeval4};

/// Modified Bessel of the first kind of order 0
///
/// Max ULP 0.5
pub fn f_i0(x: f64) -> f64 {
    let xb = x.to_bits() & 0x7fff_ffff_ffff_ffff;

    if !x.is_normal() {
        if x == 0. {
            return 1.;
        }
        if x.is_infinite() {
            return f64::INFINITY;
        }
        if x.is_nan() {
            return f64::NAN;
        }
    }

    if xb > 0x40864fe5304e83e4u64 {
        // 713.9869085439682
        return f64::INFINITY;
    }

    if xb <= 0x400ccccccccccccdu64 {
        return i0_0_to_3p6_exec(f64::from_bits(xb));
    } else if xb <= 0x401e000000000000u64 {
        return i3p6_to_7p5(f64::from_bits(xb));
    } else if xb <= 0x4023000000000000u64 {
        // 9.5
        return i0_7p5_to_9p5(f64::from_bits(xb));
    }

    i0_asympt(f64::from_bits(xb))
}

/**
Computes I0 on interval [-7.5; -3.6], [3.6; 7.5]
**/
#[inline]
fn i3p6_to_7p5(x: f64) -> f64 {
    let r = i0_3p6_to_7p5_dd(x);

    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3c56a09e667f3bcd), // 2^-57.5
        f64::from_bits(0x3c00000000000000), // 2^-63
    );
    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub != lb {
        return eval_small_hard_3p6_to_7p5(x);
    }
    r.to_f64()
}

/**
Computes I0 on interval [-7.5; -3.6], [3.6; 7.5]
as rational approximation I0 = 1 + (x/2)^2 * Pn((x/2)^2)/Qm((x/2)^2))

Relative error on interval 2^-(105.71).

Generated by Wolfram Mathematica:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=(BesselI[0,x]-1)/(x/2)^2
g[z_]:=f[2 Sqrt[z]]
{err, approx}=MiniMaxApproximation[g[z],{z,{0.0000000000001,3.6},7,6},WorkingPrecision->60]
poly=Numerator[approx][[1]];
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
poly=Denominator[approx][[1]];
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn i0_0_to_3p6_dd(x: f64) -> DoubleDouble {
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(x, x), ONE_OVER_4);
    const P: [(u64, u64); 8] = [
        (0xba93dec1e5396e30, 0x3ff0000000000000),
        (0xbc5d3d919a2b891a, 0x3fcb128f49a1f59f),
        (0xbc3c4d80de165459, 0x3f9353508fce278f),
        (0x3be7e0e75c00d411, 0x3f4b760657892e15),
        (0xbb9bc959d02076a4, 0x3ef588ff0ba5872e),
        (0x3b257756675180e4, 0x3e932e320d411521),
        (0xbaca098436a47ec6, 0x3e2285f524a51de0),
        (0x3a0e48fa0331db75, 0x3d9ee6518d82a209),
    ];
    let ps_num = f_estrin_polyeval5(
        eval_x.hi,
        f64::from_bits(0x3f4b760657892e15),
        f64::from_bits(0x3ef588ff0ba5872e),
        f64::from_bits(0x3e932e320d411521),
        f64::from_bits(0x3e2285f524a51de0),
        f64::from_bits(0x3d9ee6518d82a209),
    );
    let mut p_num = DoubleDouble::mul_f64_add(eval_x, ps_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[0]));
    const Q: [(u64, u64); 7] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3c26136ec7050a58, 0xbfa3b5c2d9782985),
        (0x3bdf9cd5be66297b, 0x3f478d5c030ea692),
        (0xbb5036196d4b865c, 0xbee1a83b6e8c6fd6),
        (0xbb1a9dafadc75858, 0x3e71ba443893032b),
        (0xba7a719ba9ed7e7f, 0xbdf6e673af3e0c66),
        (0xb9e17740b37a23ec, 0x3d6e2c993fef696f),
    ];
    let ps_den = f_polyeval4(
        eval_x.hi,
        f64::from_bits(0xbee1a83b6e8c6fd6),
        f64::from_bits(0x3e71ba443893032b),
        f64::from_bits(0xbdf6e673af3e0c66),
        f64::from_bits(0x3d6e2c993fef696f),
    );
    let mut p_den = DoubleDouble::mul_f64_add(eval_x, ps_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(eval_x, p_den, f64::from_bits(0x3ff0000000000000));
    DoubleDouble::mul_add_f64(DoubleDouble::div(p_num, p_den), eval_x, 1.)
}

// Generated by Wolfram Mathematica:
// I0(x) = 1+(x/2)^2 * R((x/2)^2)
// <<FunctionApproximations`
// ClearAll["Global`*"]
// f[x_]:=(BesselI[0,x]-1)/(x/2)^2
// g[z_]:=f[2 Sqrt[z]]
// {err, approx}=MiniMaxApproximation[g[z],{z,{3.6,7.51},8,8},WorkingPrecision->60]
// poly=Numerator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
// poly=Denominator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
#[inline]
fn i0_3p6_to_7p5_dd(x: f64) -> DoubleDouble {
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(x, x), ONE_OVER_4);
    const P: [(u64, u64); 10] = [
        (0xbae8195e94c833a1, 0x3ff0000000000000),
        (0xbc6f4db3a04cf778, 0x3fcbca374cf8efde),
        (0x3c31e334a32ed081, 0x3f9493391f88f49c),
        (0x3bb77456438b622e, 0x3f4f2aff2cd821b7),
        (0x3b312b847b83fa80, 0x3efb249e459c00fa),
        (0x3b1d3faf77d3ee5b, 0x3e9cd199c39f6d6c),
        (0xbaaf6a6a3d483df8, 0x3e331192e34cb81f),
        (0x3a406e234cb7aede, 0x3dbef6023ba17d1a),
        (0x39dee1ec666e30b5, 0x3d3c8bab78d825e9),
        (0x3910b9821c993936, 0x3ca73bf438398234),
    ];
    let ps_num = f_estrin_polyeval5(
        eval_x.hi,
        f64::from_bits(0x3e9cd199c39f6d6c),
        f64::from_bits(0x3e331192e34cb81f),
        f64::from_bits(0x3dbef6023ba17d1a),
        f64::from_bits(0x3d3c8bab78d825e9),
        f64::from_bits(0x3ca73bf438398234),
    );
    let mut p_num = DoubleDouble::mul_f64_add(eval_x, ps_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[0]));
    const Q: [(u64, u64); 10] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3c16498103ae0f29, 0xbfa0d722cc1c408a),
        (0x3ba9b44df49b7368, 0x3f41a06d24a9b89a),
        (0x3b43ef4989b8a3ed, 0xbed8363c48ecd98c),
        (0xbaf6197838a8a2ef, 0x3e6830647038f0ac),
        (0x3a96c443c7d52296, 0xbdf257666a799e31),
        (0x3a118e8a97f0df20, 0x3d753ffeb530f0c8),
        (0xb99e90b659ab1bb7, 0xbcf243374f2b7d6c),
        (0x38f647cfef513fc5, 0x3c654740fd120da3),
        (0x386d691099d0e8fc, 0xbbc9c9c826756a76),
    ];
    let ps_den = f_estrin_polyeval5(
        eval_x.hi,
        f64::from_bits(0xbdf257666a799e31),
        f64::from_bits(0x3d753ffeb530f0c8),
        f64::from_bits(0xbcf243374f2b7d6c),
        f64::from_bits(0x3c654740fd120da3),
        f64::from_bits(0xbbc9c9c826756a76),
    );
    let mut p_den = DoubleDouble::mul_f64_add(eval_x, ps_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(eval_x, p_den, f64::from_bits(0x3ff0000000000000));
    DoubleDouble::mul_add_f64(DoubleDouble::div(p_num, p_den), eval_x, 1.)
}

// Generated by Wolfram Mathematica:
// I0(x) = 1+(x/2)^2 * R((x/2)^2)
// <<FunctionApproximations`
// ClearAll["Global`*"]
// f[x_]:=(BesselI[0,x]-1)/(x/2)^2
// g[z_]:=f[2 Sqrt[z]]
// {err, approx}=MiniMaxApproximation[g[z],{z,{3.6,7.51},8,8},WorkingPrecision->60]
// poly=Numerator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
// poly=Denominator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
#[cold]
#[inline(never)]
fn eval_small_hard_3p6_to_7p5(x: f64) -> f64 {
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(x, x), ONE_OVER_4);
    const P: [(u64, u64); 10] = [
        (0xbae8195e94c833a1, 0x3ff0000000000000),
        (0xbc6f4db3a04cf778, 0x3fcbca374cf8efde),
        (0x3c31e334a32ed081, 0x3f9493391f88f49c),
        (0x3bb77456438b622e, 0x3f4f2aff2cd821b7),
        (0x3b312b847b83fa80, 0x3efb249e459c00fa),
        (0x3b1d3faf77d3ee5b, 0x3e9cd199c39f6d6c),
        (0xbaaf6a6a3d483df8, 0x3e331192e34cb81f),
        (0x3a406e234cb7aede, 0x3dbef6023ba17d1a),
        (0x39dee1ec666e30b5, 0x3d3c8bab78d825e9),
        (0x3910b9821c993936, 0x3ca73bf438398234),
    ];
    let mut p_num = DoubleDouble::mul_add(
        eval_x,
        DoubleDouble::from_bit_pair(P[9]),
        DoubleDouble::from_bit_pair(P[8]),
    );
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[7]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[6]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[0]));
    const Q: [(u64, u64); 10] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3c16498103ae0f29, 0xbfa0d722cc1c408a),
        (0x3ba9b44df49b7368, 0x3f41a06d24a9b89a),
        (0x3b43ef4989b8a3ed, 0xbed8363c48ecd98c),
        (0xbaf6197838a8a2ef, 0x3e6830647038f0ac),
        (0x3a96c443c7d52296, 0xbdf257666a799e31),
        (0x3a118e8a97f0df20, 0x3d753ffeb530f0c8),
        (0xb99e90b659ab1bb7, 0xbcf243374f2b7d6c),
        (0x38f647cfef513fc5, 0x3c654740fd120da3),
        (0x386d691099d0e8fc, 0xbbc9c9c826756a76),
    ];
    let mut p_den = DoubleDouble::mul_add(
        eval_x,
        DoubleDouble::from_bit_pair(Q[9]),
        DoubleDouble::from_bit_pair(Q[8]),
    );
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[7]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[6]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[5]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(eval_x, p_den, f64::from_bits(0x3ff0000000000000));
    let q = DoubleDouble::mul_add_f64(DoubleDouble::div(p_num, p_den), eval_x, 1.);
    q.to_f64()
}

#[inline]
pub(crate) fn i0_0_to_3p6_exec(x: f64) -> f64 {
    let r = i0_0_to_3p6_dd(x);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3c40000000000000), // 2^-59
        f64::from_bits(0x3be0000000000000), // 2^-66
    );
    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub == lb {
        return r.to_f64();
    }
    i0_0_to_3p6_hard(x)
}

// Generated by Wolfram Mathematica:
// <<FunctionApproximations`
// ClearAll["Global`*"]
// f[x_]:=(BesselI[0,x]-1)/(x/2)^2
// g[z_]:=f[2 Sqrt[z]]
// {err, approx}=MiniMaxApproximation[g[z],{z,{0.0000000000001,3.6},7,6},WorkingPrecision->60]
// poly=Numerator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
// poly=Denominator[approx][[1]];
// coeffs=CoefficientList[poly,z];
// TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
#[cold]
#[inline(never)]
fn i0_0_to_3p6_hard(x: f64) -> f64 {
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(x, x), ONE_OVER_4);
    const P: [(u64, u64); 8] = [
        (0xba93dec1e5396e30, 0x3ff0000000000000),
        (0xbc5d3d919a2b891a, 0x3fcb128f49a1f59f),
        (0xbc3c4d80de165459, 0x3f9353508fce278f),
        (0x3be7e0e75c00d411, 0x3f4b760657892e15),
        (0xbb9bc959d02076a4, 0x3ef588ff0ba5872e),
        (0x3b257756675180e4, 0x3e932e320d411521),
        (0xbaca098436a47ec6, 0x3e2285f524a51de0),
        (0x3a0e48fa0331db75, 0x3d9ee6518d82a209),
    ];
    let mut p_num = DoubleDouble::mul_add(
        eval_x,
        DoubleDouble::from_bit_pair(P[7]),
        DoubleDouble::from_bit_pair(P[6]),
    );
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(eval_x, p_num, DoubleDouble::from_bit_pair(P[0]));
    const Q: [(u64, u64); 7] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3c26136ec7050a58, 0xbfa3b5c2d9782985),
        (0x3bdf9cd5be66297b, 0x3f478d5c030ea692),
        (0xbb5036196d4b865c, 0xbee1a83b6e8c6fd6),
        (0xbb1a9dafadc75858, 0x3e71ba443893032b),
        (0xba7a719ba9ed7e7f, 0xbdf6e673af3e0c66),
        (0xb9e17740b37a23ec, 0x3d6e2c993fef696f),
    ];
    let mut p_den = DoubleDouble::mul_add(
        eval_x,
        DoubleDouble::from_bit_pair(Q[6]),
        DoubleDouble::from_bit_pair(Q[5]),
    );
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add(eval_x, p_den, DoubleDouble::from_bit_pair(Q[0]));
    let q = DoubleDouble::mul_add_f64(DoubleDouble::div(p_num, p_den), eval_x, 1.);
    q.to_f64()
}

/**
Mid-interval [7.5;9.5] generated by Wolfram:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=Sqrt[x] Exp[-x] BesselI[0,x]
g[z_]:=f[1/z]
{err, approx}=MiniMaxApproximation[g[z],{z,{1/9.5,1/7.5},11,11},WorkingPrecision->120]
num=Numerator[approx][[1]];
den=Denominator[approx][[1]];
poly=den;
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn i0_7p5_to_9p5(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_quick_recip(x);

    const P: [(u64, u64); 12] = [
        (0x3c778e3de1f76f48, 0x3fd988450531281b),
        (0xbcb572f6149f389e, 0xc01a786676fb4d3a),
        (0x3cf2f373365347ed, 0x405c0e8405fdb642),
        (0x3d276a94c8f1e627, 0xc0885e4718dfb761),
        (0x3d569f8a993434e2, 0x40b756d52d5fa90c),
        (0xbd6f953f7dd1a223, 0xc0c8818365c47790),
        (0xbd74247967fbf7b2, 0x40e8cf89daf87353),
        (0x3db449add7abb056, 0x41145d3c2d96d159),
        (0xbdc5cc822b71f891, 0xc123694c58fd039b),
        (0x3da2047ac1a6fba8, 0x415462e630bf3e7e),
        (0xbdc2f2c06eda6a95, 0xc14c6984ebdd6792),
        (0xbdf51fa85dafeca5, 0x4166a437c202d27b),
    ];

    let mut p_num = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(P[11]),
        DoubleDouble::from_bit_pair(P[10]),
    );
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[9]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[8]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[7]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[6]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[0]));

    const Q: [(u64, u64); 12] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3cde08e4cbf324d1, 0xc030b67bd69af0ca),
        (0x3cec5e4ee7e77024, 0x4071b54c0f58409c),
        (0xbd340e1131739e2f, 0xc09f140a738b14b3),
        (0x3d607673189d6644, 0x40cdb44bd822add2),
        (0xbd7793a4f1dd74d1, 0xc0e03fe2689b802d),
        (0xbd8415501228a87e, 0x410009beafea72cc),
        (0x3dcecdac2702661f, 0x4128c2073da9a447),
        (0xbdd8386404f3dec5, 0xc1389ec7d7186bf4),
        (0xbe06eb53a3e86436, 0x4168b7a2dc85ed0b),
        (0x3e098e2cefaf8299, 0xc1604f8cf34af02c),
        (0x3e1a5e496b547001, 0x41776b1e0153d1e9),
    ];

    let mut p_den = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(Q[11]),
        DoubleDouble::from_bit_pair(Q[10]),
    );
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[9]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[8]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[7]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[6]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[5]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(recip, p_den, f64::from_bits(0x3ff0000000000000));

    let z = DoubleDouble::div(p_num, p_den);

    let e = i0_exp(dx);
    let r_sqrt = DoubleDouble::from_rsqrt_fast(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt, e);

    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bc0000000000000),
        f64::from_bits(0x392bdb8cdadbe111),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_7p5_to_9p5_hard(x);
    }
    r.to_f64()
}

/**
Mid-interval [7.5;9.5] generated by Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/9.5, 1/7.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya/bessel_i0_mid_interval.sollya
**/
#[cold]
#[inline(never)]
fn i0_7p5_to_9p5_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 30] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc40e2dc_d2884163_7a151c1d_91d7acce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xd60fd904_ed8e723b_043ebb0a_c84e6b71_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -129,
            mantissa: 0x826d75fb_ead03ab6_3812b81a_82ae9e16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xab464d96_4d8d2351_036d2731_61f33b19_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -117,
            mantissa: 0x912d7ff1_b51e07c4_674c4595_6df64222_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -112,
            mantissa: 0xbc8a9db2_47fdd5a1_8b7c144f_5e8c2fe1_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -107,
            mantissa: 0xc2b4b2e7_c4166e86_7143b733_7bc1886e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -102,
            mantissa: 0xa41c2372_9a91cd00_ea6ade71_7d2f42a8_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -98,
            mantissa: 0xe5f8aaa7_f2c866b6_ce66dbb4_dd4230ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -93,
            mantissa: 0x87bff342_b4fe58f7_139c6679_a2189ccd_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -89,
            mantissa: 0x885ca780_fe663093_3fa35150_4f9f9dbe_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -86,
            mantissa: 0xead2af4f_e2c4335b_b94f0344_3738d42f_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -82,
            mantissa: 0xae41260b_140008bd_6060f8ac_8c50d2b2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -79,
            mantissa: 0xdfbff6f7_8ae5df08_d19a1b22_5e4d2ae7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -76,
            mantissa: 0xf932115e_b49672b5_56f3bdcc_1249f108_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf10822de_47e2d8bd_87b0dbf5_20bd8bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -70,
            mantissa: 0xca7d3a1e_aa7d6fd0_5d3851b7_c06b6141_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -67,
            mantissa: 0x939429b8_bf029a93_dbd23d8f_81b18f78_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -65,
            mantissa: 0xba296c69_4f459398_321558f5_70d37365_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -63,
            mantissa: 0xca6906bd_16f298b3_7c715800_0e8b932a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -61,
            mantissa: 0xbc981d79_aa00aff0_822f256e_2508cd20_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0x95610c80_7e0e934d_37e8fd8e_26a91bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -58,
            mantissa: 0xc6faee68_2d02a10b_71307961_4c7089da_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -57,
            mantissa: 0xdb99648b_ea5faf8b_fa2b22cf_23519879_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -56,
            mantissa: 0xc4bfb9fc_868c1729_555e5bd7_d8d560ff_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -55,
            mantissa: 0x8b0aecb8_713e1619_d2c04466_79285901_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -55,
            mantissa: 0x9488128f_4a0b453e_b756f985_a5535449_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -56,
            mantissa: 0xdffd122b_4227df24_0fea2700_a9463ad3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0xd268f940_a7ee25f1_eb82b522_aa3bcb9e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0xb63002c8_6697c63e_625f0d0f_da7c5ab1_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let mut z = P[29];
    for i in (0..29).rev() {
        z = recip * z + P[i];
    }
    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[inline(always)]
fn exp_poly(z: f64) -> DoubleDouble {
    /* The following is a degree-4 polynomial generated by Sollya for exp(x)
    over [-2^-12.905,2^-12.905]
    with absolute error < 2^-74.34 (see sollya/Q_1.sollya). */
    const Q_1: [u64; 5] = [
        0x3ff0000000000000,
        0x3ff0000000000000,
        0x3fe0000000000000,
        0x3fc5555555997996,
        0x3fa5555555849d8d,
    ];
    let mut q = dd_fmla(f64::from_bits(Q_1[4]), z, f64::from_bits(Q_1[3]));
    q = dd_fmla(q, z, f64::from_bits(Q_1[2]));
    let h0 = dd_fmla(q, z, f64::from_bits(Q_1[1]));

    let v1 = DoubleDouble::from_exact_mult(z, h0);
    DoubleDouble::f64_add(f64::from_bits(Q_1[0]), v1)
}

#[inline]
pub(crate) fn i0_exp(r: f64) -> DoubleDouble {
    const INVLOG2: f64 = f64::from_bits(0x40b71547652b82fe);

    let k = (r * INVLOG2).round();

    const L2: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0x3d0718432a1b0e26),
        f64::from_bits(0x3f262e42ff000000),
    );

    let zh = f_fmla(L2.lo, k, f_fmla(-L2.hi, k, r));

    let bk = k as i64;
    let mk = (bk >> 12) + 0x3ff;
    let i2 = (bk >> 6) & 0x3f;
    let i1 = bk & 0x3f;

    let t0 = DoubleDouble::from_bit_pair(EXP_REDUCE_T0[i2 as usize]);
    let t1 = DoubleDouble::from_bit_pair(EXP_REDUCE_T1[i1 as usize]);
    let mut de = DoubleDouble::quick_mult(t1, t0);
    let q = exp_poly(zh);
    de = DoubleDouble::quick_mult(de, q);

    let mut du = (mk as u64).wrapping_shl(52);
    du = f64::from_bits(du).to_bits();
    DoubleDouble::quick_mult_f64(de, f64::from_bits(du))
}

/**
Generated in Wolfram:
```text
<<FunctionApproximations`
ClearAll["Global`*"]
f[x_]:=Sqrt[x] Exp[-x] BesselI[0,x]
g[z_]:=f[1/z]
{err, approx}=MiniMaxApproximation[g[z],{z,{1/709.3,1/9.5},10,10},WorkingPrecision->120]
num=Numerator[approx][[1]];
den=Denominator[approx][[1]];
poly=num;
coeffs=CoefficientList[poly,z];
TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
```
**/
#[inline]
fn i0_asympt(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_quick_recip(x);
    const P: [(u64, u64); 12] = [
        (0xbc7ca19c5d824c54, 0x3fd9884533d43651),
        (0x3cca32eb734e010e, 0xc03b7ca35caf42eb),
        (0x3d03af8238d6f25e, 0x408b92cfcaa7070f),
        (0xbd7a8ff7fdebed70, 0xc0d0a3be432cce93),
        (0xbdababdb579bb076, 0x410a77dc51f1804d),
        (0x3dc5e4e3c972832a, 0xc13cb0be2f74839c),
        (0x3e01076f9b102e38, 0x41653b064cc61661),
        (0xbe2157e700d445f4, 0xc184e1b076927460),
        (0xbdfa4577156dde56, 0x41999e9653f9dc5f),
        (0xbe47aa238a739ffe, 0xc1a130f6ded40c00),
        (0xbe331b560b6fbf4a, 0x419317f11e674cae),
        (0xbe0765596077d1e3, 0xc16024404db59d3f),
    ];

    let mut p_num = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(P[11]),
        DoubleDouble::from_bit_pair(P[10]),
    );
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[9]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[8]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[7]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[6]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[5]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[4]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[3]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[2]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[1]));
    p_num = DoubleDouble::mul_add(recip, p_num, DoubleDouble::from_bit_pair(P[0]));

    const Q: [(u64, u64); 12] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0xbcf687703e843d07, 0xc051418f1c4dd0b9),
        (0x3d468ab92cb87a0b, 0x40a15891d823e48d),
        (0x3d8bfc17e5183376, 0xc0e4fce40dd82796),
        (0xbdccbbcc2ecf8d4c, 0x4120beef869c61ec),
        (0xbdf42170b4d5d150, 0xc1523ad18834a7ed),
        (0xbe0eaa32f405afd4, 0x417b24ec57a8f480),
        (0x3e3ec900705e7252, 0xc19af2a91d23d62e),
        (0x3e3e220e274fa46b, 0x41b0cb905cc99ff5),
        (0xbe46c6c61dee11f6, 0xc1b7452e50518520),
        (0x3e3ed0fc063187bf, 0x41ac1772d1749896),
        (0xbe11c578f04f4be1, 0xc180feb5b2ca47cb),
    ];

    let mut p_den = DoubleDouble::mul_add(
        recip,
        DoubleDouble::from_bit_pair(Q[11]),
        DoubleDouble::from_bit_pair(Q[10]),
    );
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[9]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[8]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[7]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[6]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[5]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[4]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[3]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[2]));
    p_den = DoubleDouble::mul_add(recip, p_den, DoubleDouble::from_bit_pair(Q[1]));
    p_den = DoubleDouble::mul_add_f64(recip, p_den, f64::from_bits(0x3ff0000000000000));

    let z = DoubleDouble::div(p_num, p_den);

    let mut e = i0_exp(dx * 0.5);
    e = DoubleDouble::from_exact_add(e.hi, e.lo);
    let r_sqrt = DoubleDouble::from_rsqrt_fast(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt * e, e);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bc8406003b2ae42),
        f64::from_bits(0x3b8ee8f34dd80440),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_asympt_hard(x);
    }
    lb
}

#[inline]
pub(crate) fn bessel_rsqrt_hard(x: f64, recip: DyadicFloat128) -> DyadicFloat128 {
    let r = DyadicFloat128::new_from_f64(x.sqrt()) * recip;
    let fx = DyadicFloat128::new_from_f64(x);
    let rx = r * fx;
    let drx = r * fx - rx;
    const M_ONE: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Neg,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let h = r * rx + M_ONE + r * drx;
    let mut ddr = r;
    ddr.exponent -= 1; // ddr * 0.5
    let dr = ddr * h;
    r - dr
}

#[cold]
#[inline(never)]
fn i0_asympt_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 39] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc42299e_a1b28468_964d7809_1e153b28_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xcc42299e_a1b27b1d_6d33e22d_42af57ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe5ca6ed2_764f20df_18f5f2d7_2a7e8b04_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xef5d88c4_98654148_67cec9f3_2032427e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xb7439e21_53e1d4f0_aa491618_ca48a4a4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -131,
            mantissa: 0xb98cf60a_158f684f_5c72c4cd_2818c7b3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -130,
            mantissa: 0xea82ecdf_b9479960_ac88fc5b_8f9e0a7d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -128,
            mantissa: 0x8c273635_ca1c900e_98f6c71a_826d5977_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xe06125df_765ba22f_cebf8c65_52b8d48c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -116,
            mantissa: 0xe89603d0_1581f464_f20bc333_7d71a36e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -109,
            mantissa: 0xd91fbda9_3c0ebc5e_a2b78b16_9c4b2560_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -102,
            mantissa: 0xa78e0095_bfa0f966_97da5569_f60f8aa4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -96,
            mantissa: 0xd8b22ab2_a8dde015_5622fed3_9a60f561_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -90,
            mantissa: 0xece6470e_66c24229_037f3c2f_416c833a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -84,
            mantissa: 0xdc8e3464_a24e8206_dbfe3ba9_11703acf_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -78,
            mantissa: 0xaff3b9fb_40dda7ac_89cf17a8_bea6e2f2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf1cb3f14_3e89cd6a_2dc6167a_ce504577_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -67,
            mantissa: 0x8fb0d81a_a3692efd_189ec80d_0aae5d37_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -62,
            mantissa: 0x94347114_15198a4d_6317caec_2faff732_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0x84ff7613_714a7551_09223bb6_1f49312d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -53,
            mantissa: 0xd0145383_8c852144_cfeeeea9_b4baa304_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -48,
            mantissa: 0x8e109265_a66393e8_a33646c5_85d0ba16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -44,
            mantissa: 0xa9671293_1a0d6041_51cc9bc0_ad2461df_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -40,
            mantissa: 0xb061afcc_6f4d05d2_b926d5d9_b47c0172_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -36,
            mantissa: 0xa039d17c_4d55483a_2b39d90e_d8e03de3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -33,
            mantissa: 0xfd92ae02_a0366717_bd1331a2_19b3916c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -29,
            mantissa: 0xae5bfdae_50bb66d4_2ac34bea_4ba9b128_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -26,
            mantissa: 0xcfa58c78_a4167a6e_97ae7616_f0553da3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -23,
            mantissa: 0xd52793cf_74ac26bd_d5800287_97bb5656_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -20,
            mantissa: 0xbb737ea1_59a1ab1b_203d09f3_53293bfc_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -17,
            mantissa: 0x8c172597_97519909_d450bc5e_f7346a1a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -15,
            mantissa: 0xb01241b7_f476dded_68756bd7_93311623_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -13,
            mantissa: 0xb77a8654_a8c8cfb6_86fbd12f_20aa21c6_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -11,
            mantissa: 0x9b85f327_836de71e_0a95c587_df73dd47_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xd0c72b4a_81123937_16778b17_feaab3f7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -9,
            mantissa: 0xd54b34b5_08f7c7a1_53a5d591_64f5be90_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -8,
            mantissa: 0x9b9b8af7_85bf3bf1_7158ff4f_6d389faa_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -8,
            mantissa: 0x90351b61_b023a397_22d92dce_f0326527_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xfeb8c9fd_06312e7b_7e5a02a3_0147801d_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let mut z = P[38];
    for i in (0..38).rev() {
        z = recip * z + P[i];
    }

    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_i0() {
        assert!(f_i0(f64::NAN).is_nan());
        assert_eq!(f_i0(f64::INFINITY), f64::INFINITY);
        assert_eq!(f_i0(f64::NEG_INFINITY), f64::INFINITY);
        assert_eq!(f_i0(7.500000000788034), 268.1613117118702);
        assert_eq!(f_i0(715.), f64::INFINITY);
        assert_eq!(f_i0(12.), 18948.925349296307);
        assert_eq!(f_i0(16.), 893446.227920105);
        assert_eq!(f_i0(18.432), 9463892.87209841);
        assert_eq!(f_i0(26.432), 23507752424.350075);
        assert_eq!(f_i0(0.2), 1.010025027795146);
        assert_eq!(f_i0(7.5), 268.16131151518937);
        assert_eq!(f_i0(-1.5), 1.646723189772891);
    }
}
