/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::common::f_fmla;
use crate::double_double::DoubleDouble;
use crate::dyadic_float::{DyadicFloat128, DyadicSign};
use crate::exponents::{EXP_REDUCE_T0, EXP_REDUCE_T1, rational128_exp};
use crate::polyeval::{
    PolyevalMla, f_horner_polyeval21, f_horner_polyeval30, f_polyeval20, f_polyeval30, f_polyeval39,
};
use std::ops::Mul;

/// Modified Bessel of the first kind of order 0
///
/// Max ULP 0.5003
pub fn f_i0(x: f64) -> f64 {
    let xb = x.to_bits() & 0x7fff_ffff_ffff_ffff;

    if !x.is_normal() {
        if x == 0. {
            return 1.;
        }
        if x.is_infinite() {
            return f64::INFINITY;
        }
        if x.is_nan() {
            return f64::NAN;
        }
    }

    if xb > 0x40864fe5304e83e4u64 {
        // 713.9869085439682
        return f64::INFINITY;
    }

    if xb <= 0x400ccccccccccccdu64 {
        return i0_0_to_3p6_exec(f64::from_bits(xb));
    } else if xb <= 0x401e000000000000u64 {
        return i3p6_to_7p5(f64::from_bits(xb));
    } else if xb <= 0x4023000000000000u64 {
        // 9.5
        return i0_7p5_to_9p5(f64::from_bits(xb));
    }

    i0_asympt(f64::from_bits(xb))
}

#[inline(always)]
#[allow(clippy::too_many_arguments)]
pub(crate) fn f_horner_polyeval11<T: PolyevalMla + Copy + Mul<T, Output = T>>(
    x: T,
    a0: T,
    a1: T,
    a2: T,
    a3: T,
    a4: T,
    a5: T,
    a6: T,
    a7: T,
    a8: T,
    a9: T,
    a10: T,
) -> T {
    let z00 = T::polyeval_mla(x, a10, a9);
    let z0 = T::polyeval_mla(x, z00, a8);
    let t0 = T::polyeval_mla(x, z0, a7);
    let t01 = T::polyeval_mla(x, t0, a6);
    let t1 = T::polyeval_mla(x, t01, a5);
    let t2 = T::polyeval_mla(x, t1, a4);
    let t3 = T::polyeval_mla(x, t2, a3);
    let t4 = T::polyeval_mla(x, t3, a2);
    let t5 = T::polyeval_mla(x, t4, a1);
    T::polyeval_mla(x, t5, a0)
}

#[inline(always)]
#[allow(clippy::too_many_arguments)]
pub(crate) fn f_horner_polyeval9<T: PolyevalMla + Copy + Mul<T, Output = T>>(
    x: T,
    a0: T,
    a1: T,
    a2: T,
    a3: T,
    a4: T,
    a5: T,
    a6: T,
    a7: T,
    a8: T,
) -> T {
    let t0 = T::polyeval_mla(x, a8, a7);
    let t01 = T::polyeval_mla(x, t0, a6);
    let t1 = T::polyeval_mla(x, t01, a5);
    let t2 = T::polyeval_mla(x, t1, a4);
    let t3 = T::polyeval_mla(x, t2, a3);
    let t4 = T::polyeval_mla(x, t3, a2);
    let t5 = T::polyeval_mla(x, t4, a1);
    T::polyeval_mla(x, t5, a0)
}

/**
Computes I0 on interval [-7.5; -3.6], [3.6; 7.5]
as rational approximation I0 = 1 + (x/2)^2 * Pn((x/2)^2)/Qm((x/2)^2))
where n = 16 and m = 0.

Relative error on interval 2^-(105.71).

Generated by SageMath:
```python
from sage.all import *
from mpmath import mp, besseli, taylor

mp.prec = 450

def shifted_i0(x):
    return besseli(0, x) - mp.mpf(1)

terms = 100
from mpmath import taylor
coeffs = taylor(shifted_i0, 0, terms)

R = PolynomialRing(RealField(450), 'y')
y = R.gen()
f = R(0)

for n in range(2, terms, 2):
    k = n // 2
    c = RealField(450)(coeffs[n])
    if n >= 1:
        f += R(c) * y**(k-1) * (4**k)
    else:
        f += R(c) * y**(k-1) * (4**k)

# See the series
print(f)
```
See ./notes/bessel_i0.ipynb for generation

Next step is poly generation in Sollya see ./notes/bessel_sollya/bessel_i0_small.sollya for generation
**/
#[inline]
fn i3p6_to_7p5(x: f64) -> f64 {
    let r = i0_0_to_3p6_dd(x);

    const ERR: f64 = f64::from_bits(0x3c3ee8f34dd80440);

    let err = f_fmla(r.hi, f64::from_bits(0x3a08406003b2ae42), ERR);

    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub != lb {
        return eval_small_hard_3p6_to_7p5(x);
    }
    r.to_f64()
}

#[inline]
fn i0_0_to_3p6_dd(x: f64) -> DoubleDouble {
    let dx = x;
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(dx, dx), ONE_OVER_4);
    const C_HI: [u64; 11] = [
        0x3d35601885e63fac,
        0x3cc69ca9cf3b58eb,
        0x3c54197a7f54eb39,
        0x3bde72559462814f,
        0x3b63e22d79919a4b,
        0x3ae69f7cccd0fd97,
        0x3a669f8eebc21ada,
        0x39e40920f41b8490,
        0x395fc34bd48c842f,
        0x38d5afe40c297100,
        0x385235b4bae18dd0,
    ];

    let r = f_horner_polyeval11(
        eval_x.to_f64(),
        f64::from_bits(C_HI[0]),
        f64::from_bits(C_HI[1]),
        f64::from_bits(C_HI[2]),
        f64::from_bits(C_HI[3]),
        f64::from_bits(C_HI[4]),
        f64::from_bits(C_HI[5]),
        f64::from_bits(C_HI[6]),
        f64::from_bits(C_HI[7]),
        f64::from_bits(C_HI[8]),
        f64::from_bits(C_HI[9]),
        f64::from_bits(C_HI[10]),
    );

    const C: [(u64, u64); 9] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3aa39fd120000000, 0x3fd0000000000000),
        (0x3c3c71c6f85e8f3e, 0x3f9c71c71c71c71c),
        (0x3bfc71cb05d4728c, 0x3f5c71c71c71c71c),
        (0x3b52234fc899bd00, 0x3f123456789abcdf),
        (0xbb4b54d084479968, 0x3ec02e85c0898b71),
        (0xbb06f32cc666cec1, 0x3e6522a43f65486a),
        (0x3a8179e1fd68e9f0, 0x3e0522a43f65486a),
        (0x3a467a15395c5c36, 0x3da0b313289be0af),
    ];

    let mut p = DoubleDouble::mul_f64_add(eval_x, r, DoubleDouble::from_bit_pair(C[8]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[7]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[6]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[5]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[4]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[3]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[2]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[1]));
    p = DoubleDouble::mul_add_f64(eval_x, p, f64::from_bits(C[0].1));

    let z = DoubleDouble::quick_mult(p, eval_x);

    DoubleDouble::full_add_f64(z, 1.)
}

#[cold]
#[inline(never)]
fn eval_small_hard_3p6_to_7p5(x: f64) -> f64 {
    // See ./notes/bessel_sollya/bessel_i0_small_rational.sollya
    static C: [DyadicFloat128; 21] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -127,
            mantissa: 0x80000000_00000000_0000004e_31bffd08_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -130,
            mantissa: 0xffffffff_ffffffff_fffff617_e5690b92_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe38e38e3_8e38e38e_38e426b2_d0ca3408_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -137,
            mantissa: 0xe38e38e3_8e38e38e_38d7fbda_568ad104_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -141,
            mantissa: 0x91a2b3c4_d5e6f809_1aca6c9f_f464540c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -146,
            mantissa: 0x81742e04_4c5b8724_7c2842de_0eca2c4a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -152,
            mantissa: 0xa91521fb_2a434d41_05c40297_e907574a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -158,
            mantissa: 0xa91521fb_2a434d15_23afa32e_ed7ac73e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -164,
            mantissa: 0x85989944_df05c86b_64270ef5_543b316a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -171,
            mantissa: 0xab00c42f_31f26eaf_cd745bd6_2e0ef9ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -178,
            mantissa: 0xb4e54e79_dc082ec5_4d1321a1_df8664ec_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -185,
            mantissa: 0xa0cbd3fa_8962023f_64172213_0435e6ac_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -193,
            mantissa: 0xf392aca7_a4b8283e_3c607d74_10c95a40_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -200,
            mantissa: 0x9f116b84_43e00084_0b595646_94fc0b2e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -208,
            mantissa: 0xb4fbed99_1bc7c86a_abd70d3e_3f23060e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -216,
            mantissa: 0xb4fbe5d8_039415a8_dd11f34f_63bffa26_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -224,
            mantissa: 0xa051f028_67ca2964_021e6d9e_1bcbd9bc_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -233,
            mantissa: 0xfd49af7a_f395c504_70f37e03_b086d2ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -241,
            mantissa: 0xb4369521_9ef1c21f_83b4f7c8_20a81126_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -250,
            mantissa: 0xdde7c5db_c06182e7_ff123ae2_af7cb5ae_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -258,
            mantissa: 0xa981fcef_953ccc14_3e27285a_89ea06cc_u128,
        },
    ];

    const ONES: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Pos,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let dx = DyadicFloat128::new_from_f64(x);
    let mut eval_x = dx * dx;
    eval_x.exponent -= 2; // div by 4
    let p = f_horner_polyeval21(
        eval_x, C[0], C[1], C[2], C[3], C[4], C[5], C[6], C[7], C[8], C[9], C[10], C[11], C[12],
        C[13], C[14], C[15], C[16], C[17], C[18], C[19], C[20],
    );
    let z = p * eval_x;
    (z + ONES).fast_as_f64()
}

/**
Computes I0 on interval [-3.6; 3.6]
as rational approximation I0 = 1 + (x/2)^2 * Pn((x/2)^2)/Qm((x/2)^2))
where n = 16 and m = 0.

Relative error on interval 2^-(105.71).

Generated by SageMath:
```python
from sage.all import *
from mpmath import mp, besseli, taylor

mp.prec = 450

def shifted_i0(x):
    return besseli(0, x) - mp.mpf(1)

terms = 100
from mpmath import taylor
coeffs = taylor(shifted_i0, 0, terms)

R = PolynomialRing(RealField(450), 'y')
y = R.gen()
f = R(0)

for n in range(2, terms, 2):
    k = n // 2
    c = RealField(450)(coeffs[n])
    if n >= 1:
        f += R(c) * y**(k-1) * (4**k)
    else:
        f += R(c) * y**(k-1) * (4**k)

# See the series
print(f)
```
See ./notes/bessel_i0.ipynb for generation

Next step is poly generation in Sollya see ./notes/bessel_sollya/bessel_i0_small.sollya for generation

Poly relative error: 2^(-105.765)
**/
#[inline]
pub(crate) fn i0_0_to_3p5(x: f64) -> DoubleDouble {
    let dx = x;
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(dx, dx), ONE_OVER_4);
    const C_HI: [u64; 9] = [
        0x3da0b313289c087d,
        0x3d35601885de0d87,
        0x3cc69ca9d07b4d4e,
        0x3c54197a5b099c46,
        0x3bde725bad826bd7,
        0x3b63e1cdcd154eac,
        0x3ae6a7c8d18207c3,
        0x3a66248c282e66c4,
        0x39e842fd795f6279,
    ];

    let r = f_horner_polyeval9(
        eval_x.to_f64(),
        f64::from_bits(C_HI[0]),
        f64::from_bits(C_HI[1]),
        f64::from_bits(C_HI[2]),
        f64::from_bits(C_HI[3]),
        f64::from_bits(C_HI[4]),
        f64::from_bits(C_HI[5]),
        f64::from_bits(C_HI[6]),
        f64::from_bits(C_HI[7]),
        f64::from_bits(C_HI[8]),
    );

    const C: [(u64, u64); 8] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0xbab3667368000000, 0x3fd0000000000000),
        (0x3c3c71c86199b4e1, 0x3f9c71c71c71c71c),
        (0x3bfc714fd7436f00, 0x3f5c71c71c71c71c),
        (0x3b57bb62d8bab780, 0x3f123456789abcdf),
        (0xbb577543315e9f34, 0x3ec02e85c0898b71),
        (0x3afee1fbdf2198e0, 0x3e6522a43f65486f),
        (0x3aad86d6b7b0537f, 0x3e0522a43f65474f),
    ];

    let mut p = DoubleDouble::mul_f64_add(eval_x, r, DoubleDouble::from_bit_pair(C[7]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[6]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[5]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[4]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[3]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[2]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[1]));
    p = DoubleDouble::mul_add_f64(eval_x, p, f64::from_bits(C[0].1));

    let z = DoubleDouble::quick_mult(p, eval_x);

    DoubleDouble::full_add_f64(z, 1.)
}

#[inline]
pub(crate) fn i0_0_to_3p6_exec(x: f64) -> f64 {
    let r = i0_0_to_3p6_dd(x);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3c20000000000000),
        f64::from_bits(0x3970000000000000),
    );
    let ub = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if ub == lb {
        return r.to_f64();
    }
    i0_0_to_3p6_hard(x)
}

#[cold]
#[inline(never)]
fn i0_0_to_3p6_hard(x: f64) -> f64 {
    // See ./notes/bessel_sollya/bessel_i0_small_rational128.sollya
    let mut dx = DyadicFloat128::new_from_f64(x);
    dx = dx * dx;
    dx.exponent -= 2; // * 0.25
    const P: [DyadicFloat128; 20] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -127,
            mantissa: 0x80000000_00000000_00000000_00000000_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0x80000000_00000000_00000000_00000008_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe38e38e3_8e38e38e_38e38e38_e38e22c4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -137,
            mantissa: 0xe38e38e3_8e38e38e_38e38e38_e3a43412_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -141,
            mantissa: 0x91a2b3c4_d5e6f809_1a2b3c4d_5332b504_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -146,
            mantissa: 0x81742e04_4c5b8724_8909fcbd_7c995b8a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -152,
            mantissa: 0xa91521fb_2a434d3f_649f4edc_3e07de2a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -158,
            mantissa: 0xa91521fb_2a434d3f_64a291ec_56f26dc6_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -164,
            mantissa: 0x85989944_df05c4ef_b6731346_f776e9ba_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -171,
            mantissa: 0xab00c42f_31f2e79a_15232ee1_4ce32720_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -178,
            mantissa: 0xb4e54e79_dbfa9bbc_4a391754_f8b1e038_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -185,
            mantissa: 0xa0cbd3fa_8aa605f4_ed9568b3_c02893ce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -193,
            mantissa: 0xf392aca7_7281aa35_fccc9f5c_d105e062_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -200,
            mantissa: 0x9f116b87_7ea9f5fd_e26b0cc9_056b7fbe_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -208,
            mantissa: 0xb4fbed40_e04899a4_0b62c76f_aad78b72_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -216,
            mantissa: 0xb4fbedb2_7b0d92fa_2b9dee5e_8f241966_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -224,
            mantissa: 0xa05157e0_217cd73b_3a7d1681_7d9e923c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -233,
            mantissa: 0xfd5dfb7b_c3d1fe5b_a3491aa5_bc061ec0_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -241,
            mantissa: 0xb306b987_18677d4c_f4c4eca9_5d30e83a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -250,
            mantissa: 0xf94742a0_7060713c_15a39160_c3b15b1e_u128,
        },
    ];
    const ONE: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Pos,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let p = f_polyeval20(
        dx, P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10], P[11], P[12], P[13],
        P[14], P[15], P[16], P[17], P[18], P[19],
    );
    let z = p * dx;
    (z + ONE).fast_as_f64()
}

/**
Mid-interval [7.5;9.5] generated by Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/9.5, 1/7.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya/bessel_i0_mid_interval.sollya
**/
#[inline]
fn i0_7p5_to_9p5(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_recip(x);
    let z = f_polyeval30(
        recip,
        DoubleDouble::from_bit_pair((0x3c44ae0a81a58637, 0x3fd9881c5b9bafec)),
        DoubleDouble::from_bit_pair((0xbc158a6b63dc8af9, 0x3faac1fb162436ca)),
        DoubleDouble::from_bit_pair((0x3c3aebf3e28b8c95, 0xbfd04dae24f51f9d)),
        DoubleDouble::from_bit_pair((0xbcaa2a59a27e11f9, 0x403568c8fba2199d)),
        DoubleDouble::from_bit_pair((0xbd394ffa78b8a5b7, 0xc09225af61795385)),
        DoubleDouble::from_bit_pair((0x3d70c9c70bb76c23, 0x40e79152e7fa2751)),
        DoubleDouble::from_bit_pair((0xbdbc115588be01a3, 0xc138569583c89da1)),
        DoubleDouble::from_bit_pair((0xbe213053d35a908c, 0x41848383b28fc248)),
        DoubleDouble::from_bit_pair((0xbe5130de9bcca0d1, 0xc1ccbf1445575859)),
        DoubleDouble::from_bit_pair((0x3ebaf84a7d3b89c8, 0x4210f7fdc1a50923)),
        DoubleDouble::from_bit_pair((0x3ed03871420ddb40, 0xc2510b9440d14c2c)),
        DoubleDouble::from_bit_pair((0x3efa6b2431be80d2, 0x428d5a54ab9e440d)),
        DoubleDouble::from_bit_pair((0xbf35e74181dbd249, 0xc2c5c823c66610fe)),
        DoubleDouble::from_bit_pair((0x3f69f2d1b6225347, 0x42fbf7fd8608902f)),
        DoubleDouble::from_bit_pair((0x3fcd423410b6c65e, 0xc32f26408db53d52)),
        DoubleDouble::from_bit_pair((0x3ff168cc3ec817af, 0x435e2102a8ceaf38)),
        DoubleDouble::from_bit_pair((0x40247cde607d8353, 0xc3894fa5b42b4153)),
        DoubleDouble::from_bit_pair((0x4055e52a5af7f70c, 0x43b27283f63ea2d4)),
        DoubleDouble::from_bit_pair((0x4071992ce8e3e252, 0xc3d7452bcc2bc149)),
        DoubleDouble::from_bit_pair((0x4079748416f2c4e3, 0x43f94d1eb6217d4e)),
        DoubleDouble::from_bit_pair((0xc0b1d14504809360, 0xc417930172f74ac4)),
        DoubleDouble::from_bit_pair((0xc0d0a6bb0781a075, 0x4432ac1f8da88117)),
        DoubleDouble::from_bit_pair((0xc0e4f963c6208e13, 0xc448df5abc8610f5)),
        DoubleDouble::from_bit_pair((0xc0d878d45eeda143, 0x445b7328a866305e)),
        DoubleDouble::from_bit_pair((0xc0f3b1b945b2556d, 0xc46897f32678bf64)),
        DoubleDouble::from_bit_pair((0x411a7c14045a0333, 0x4471615a27c20e76)),
        DoubleDouble::from_bit_pair((0x411986310b671c57, 0xc47290fde46108b2)),
        DoubleDouble::from_bit_pair((0xc100f4efb583ba56, 0x446bff9a0735e3c3)),
        DoubleDouble::from_bit_pair((0xc0eab922d08f1fdb, 0xc45a4d154b5765c3)),
        DoubleDouble::from_bit_pair((0x40daac42df9f1543, 0x4436c5f4f53ab38e)),
    );
    let e = i0_exp(dx);
    let r_sqrt = DoubleDouble::from_rsqrt(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt, e);

    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bb6a09e667f3bcd),
        f64::from_bits(0x392bdb8cdadbe111),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_7p5_to_9p5_hard(x);
    }
    r.to_f64()
}

/**
Mid-interval [7.5;9.5] generated by Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/9.5, 1/7.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya/bessel_i0_mid_interval.sollya
**/
#[cold]
#[inline(never)]
fn i0_7p5_to_9p5_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 30] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc40e2dc_d2884163_7a151c1d_91d7acce_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xd60fd904_ed8e723b_043ebb0a_c84e6b71_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -129,
            mantissa: 0x826d75fb_ead03ab6_3812b81a_82ae9e16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xab464d96_4d8d2351_036d2731_61f33b19_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -117,
            mantissa: 0x912d7ff1_b51e07c4_674c4595_6df64222_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -112,
            mantissa: 0xbc8a9db2_47fdd5a1_8b7c144f_5e8c2fe1_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -107,
            mantissa: 0xc2b4b2e7_c4166e86_7143b733_7bc1886e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -102,
            mantissa: 0xa41c2372_9a91cd00_ea6ade71_7d2f42a8_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -98,
            mantissa: 0xe5f8aaa7_f2c866b6_ce66dbb4_dd4230ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -93,
            mantissa: 0x87bff342_b4fe58f7_139c6679_a2189ccd_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -89,
            mantissa: 0x885ca780_fe663093_3fa35150_4f9f9dbe_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -86,
            mantissa: 0xead2af4f_e2c4335b_b94f0344_3738d42f_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -82,
            mantissa: 0xae41260b_140008bd_6060f8ac_8c50d2b2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -79,
            mantissa: 0xdfbff6f7_8ae5df08_d19a1b22_5e4d2ae7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -76,
            mantissa: 0xf932115e_b49672b5_56f3bdcc_1249f108_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf10822de_47e2d8bd_87b0dbf5_20bd8bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -70,
            mantissa: 0xca7d3a1e_aa7d6fd0_5d3851b7_c06b6141_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -67,
            mantissa: 0x939429b8_bf029a93_dbd23d8f_81b18f78_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -65,
            mantissa: 0xba296c69_4f459398_321558f5_70d37365_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -63,
            mantissa: 0xca6906bd_16f298b3_7c715800_0e8b932a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -61,
            mantissa: 0xbc981d79_aa00aff0_822f256e_2508cd20_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0x95610c80_7e0e934d_37e8fd8e_26a91bb2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -58,
            mantissa: 0xc6faee68_2d02a10b_71307961_4c7089da_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -57,
            mantissa: 0xdb99648b_ea5faf8b_fa2b22cf_23519879_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -56,
            mantissa: 0xc4bfb9fc_868c1729_555e5bd7_d8d560ff_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -55,
            mantissa: 0x8b0aecb8_713e1619_d2c04466_79285901_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -55,
            mantissa: 0x9488128f_4a0b453e_b756f985_a5535449_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -56,
            mantissa: 0xdffd122b_4227df24_0fea2700_a9463ad3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0xd268f940_a7ee25f1_eb82b522_aa3bcb9e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -59,
            mantissa: 0xb63002c8_6697c63e_625f0d0f_da7c5ab1_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let z = f_horner_polyeval30(
        recip, P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10], P[11], P[12],
        P[13], P[14], P[15], P[16], P[17], P[18], P[19], P[20], P[21], P[22], P[23], P[24], P[25],
        P[26], P[27], P[28], P[29],
    );
    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[inline(always)]
fn exp_poly(z: f64) -> DoubleDouble {
    /* The following is a degree-6 polynomial generated by Sollya for exp(x)
    over [-2^-12.905,2^-12.905]
    with absolute error < 2^-108.634 (see sollya/bessel_i0_exp.sollya). */
    const Q: [(u64, u64); 7] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3a20e40000000000, 0x3ff0000000000000),
        (0x3a04820000000000, 0x3fe0000000000000),
        (0x3c6537b87598eb35, 0x3fc5555555555555),
        (0x3c453e1164955528, 0x3fa5555555555555),
        (0xbc236e26aec872a7, 0x3f8111111144fbef),
        (0xbbd53d924ae90c8c, 0x3f56c16c16ffeecc),
    ];
    let mut p = DoubleDouble::quick_mult_f64(DoubleDouble::from_bit_pair(Q[6]), z);
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[5]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[4]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[3]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[2]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[1]));
    DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[0]))
}

#[inline]
pub(crate) fn i0_exp(r: f64) -> DoubleDouble {
    const INVLOG2: f64 = f64::from_bits(0x40b71547652b82fe);

    let k = (r * INVLOG2).round();

    const L2: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0x3d0718432a1b0e26),
        f64::from_bits(0x3f262e42ff000000),
    );

    let zh = f_fmla(L2.lo, k, f_fmla(-L2.hi, k, r));

    let bk = k as i64;
    let mk = (bk >> 12) + 0x3ff;
    let i2 = (bk >> 6) & 0x3f;
    let i1 = bk & 0x3f;

    let t0 = DoubleDouble::from_bit_pair(EXP_REDUCE_T0[i2 as usize]);
    let t1 = DoubleDouble::from_bit_pair(EXP_REDUCE_T1[i1 as usize]);
    let mut de = DoubleDouble::quick_mult(t1, t0);
    let q = exp_poly(zh);
    de = DoubleDouble::quick_mult(de, q);

    let mut du = (mk as u64).wrapping_shl(52);
    du = f64::from_bits(du).to_bits();
    DoubleDouble::quick_mult_f64(de, f64::from_bits(du))
}

/**
Generated in Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/709.3, 1/9.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya
**/
#[inline]
fn i0_asympt(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_recip(x);
    let z = f_polyeval30(
        recip,
        DoubleDouble::from_bit_pair((0xbc7c1377032a0a64, 0x3fd9884533d43651)),
        DoubleDouble::from_bit_pair((0xbc45e47ff971096d, 0x3fa9884533d43587)),
        DoubleDouble::from_bit_pair((0x3c34fc7cc8b988f9, 0x3f9cb94dda552f2b)),
        DoubleDouble::from_bit_pair((0x3c36e54b0dd085b7, 0x3f9debb109b61dc9)),
        DoubleDouble::from_bit_pair((0x3c41e6868f4d5917, 0x3fa6e87ee54a8972)),
        DoubleDouble::from_bit_pair((0x3c3989a41a24145c, 0x3fb72bdb6c41cbbd)),
        DoubleDouble::from_bit_pair((0x3c4aad4c46560cd4, 0x3fcf799a83545bed)),
        DoubleDouble::from_bit_pair((0xbc82e815160a2300, 0xbffdff58df7716df)),
        DoubleDouble::from_bit_pair((0x3ce520ae923832b0, 0x40724ffcc87d2082)),
        DoubleDouble::from_bit_pair((0xbd75b73448c9c752, 0xc0d961e4d922e0d1)),
        DoubleDouble::from_bit_pair((0xbdb0cf0f1ea7bc63, 0x413c7d324261577c)),
        DoubleDouble::from_bit_pair((0x3e3901959e0aa1a1, 0xc199fa44d7ec023b)),
        DoubleDouble::from_bit_pair((0x3e93422362429a42, 0x41f372843e5aaa6e)),
        DoubleDouble::from_bit_pair((0x3eb3a84ccf581408, 0xc24817811300fb90)),
        DoubleDouble::from_bit_pair((0x3f3b1e6094a03a23, 0x4298d719a784b4de)),
        DoubleDouble::from_bit_pair((0x3f2bfaa33420d672, 0xc2e567ed0056e1d6)),
        DoubleDouble::from_bit_pair((0x3fcfb61f1b1d875c, 0x432eea4c5a7430b4)),
        DoubleDouble::from_bit_pair((0xc01e6689f1e0d774, 0xc372ba656951ac2e)),
        DoubleDouble::from_bit_pair((0x4050ce0115c626f7, 0x43b3072820882e2e)),
        DoubleDouble::from_bit_pair((0xc099dc6f5e058416, 0xc3f02e1c0674446f)),
        DoubleDouble::from_bit_pair((0x40a12887892585ea, 0x4426f1a3d0faf34c)),
        DoubleDouble::from_bit_pair((0x40f337dd37031f59, 0xc45af84ecdbce892)),
        DoubleDouble::from_bit_pair((0x412aaa80ab5e7dd6, 0x448a0e9fa4493dae)),
        DoubleDouble::from_bit_pair((0xc1425899c2a4bb3a, 0xc4b471a56a81cc70)),
        DoubleDouble::from_bit_pair((0xc15ad42ecaac864f, 0x44d99ba476302220)),
        DoubleDouble::from_bit_pair((0xc195c38e309c4549, 0xc4f8f9c0970973a8)),
        DoubleDouble::from_bit_pair((0x4197ec13566e7076, 0x4512439547684b69)),
        DoubleDouble::from_bit_pair((0x41b14b88b32a34fb, 0xc522d4bba3771a58)),
        DoubleDouble::from_bit_pair((0xc1bc7e986417022d, 0x4528661e01397b58)),
        DoubleDouble::from_bit_pair((0x41b431a9bac39ee8, 0xc51dded7dbe00d0a)),
    );

    let e = i0_exp(dx * 0.5);
    let r_sqrt = DoubleDouble::from_rsqrt(dx);
    let r = DoubleDouble::quick_mult(z * r_sqrt * e, e);
    let err = f_fmla(
        r.hi,
        f64::from_bits(0x3bc8406003b2ae42),
        f64::from_bits(0x3b8ee8f34dd80440),
    );
    let up = r.hi + (r.lo + err);
    let lb = r.hi + (r.lo - err);
    if up != lb {
        return i0_asympt_hard(x);
    }
    lb
}

#[inline]
pub(crate) fn bessel_rsqrt_hard(x: f64, recip: DyadicFloat128) -> DyadicFloat128 {
    let r = DyadicFloat128::new_from_f64(x.sqrt()) * recip;
    let fx = DyadicFloat128::new_from_f64(x);
    let rx = r * fx;
    let drx = r * fx - rx;
    const M_ONE: DyadicFloat128 = DyadicFloat128 {
        sign: DyadicSign::Neg,
        exponent: -127,
        mantissa: 0x80000000_00000000_00000000_00000000_u128,
    };
    let h = r * rx + M_ONE + r * drx;
    let mut ddr = r;
    ddr.exponent -= 1; // ddr * 0.5
    let dr = ddr * h;
    r - dr
}

#[cold]
#[inline(never)]
fn i0_asympt_hard(x: f64) -> f64 {
    static P: [DyadicFloat128; 39] = [
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -129,
            mantissa: 0xcc42299e_a1b28468_964d7809_1e153b28_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xcc42299e_a1b27b1d_6d33e22d_42af57ad_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xe5ca6ed2_764f20df_18f5f2d7_2a7e8b04_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -133,
            mantissa: 0xef5d88c4_98654148_67cec9f3_2032427e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -132,
            mantissa: 0xb7439e21_53e1d4f0_aa491618_ca48a4a4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -131,
            mantissa: 0xb98cf60a_158f684f_5c72c4cd_2818c7b3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -130,
            mantissa: 0xea82ecdf_b9479960_ac88fc5b_8f9e0a7d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -128,
            mantissa: 0x8c273635_ca1c900e_98f6c71a_826d5977_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -123,
            mantissa: 0xe06125df_765ba22f_cebf8c65_52b8d48c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -116,
            mantissa: 0xe89603d0_1581f464_f20bc333_7d71a36e_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -109,
            mantissa: 0xd91fbda9_3c0ebc5e_a2b78b16_9c4b2560_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -102,
            mantissa: 0xa78e0095_bfa0f966_97da5569_f60f8aa4_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -96,
            mantissa: 0xd8b22ab2_a8dde015_5622fed3_9a60f561_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -90,
            mantissa: 0xece6470e_66c24229_037f3c2f_416c833a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -84,
            mantissa: 0xdc8e3464_a24e8206_dbfe3ba9_11703acf_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -78,
            mantissa: 0xaff3b9fb_40dda7ac_89cf17a8_bea6e2f2_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -73,
            mantissa: 0xf1cb3f14_3e89cd6a_2dc6167a_ce504577_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -67,
            mantissa: 0x8fb0d81a_a3692efd_189ec80d_0aae5d37_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -62,
            mantissa: 0x94347114_15198a4d_6317caec_2faff732_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -57,
            mantissa: 0x84ff7613_714a7551_09223bb6_1f49312d_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -53,
            mantissa: 0xd0145383_8c852144_cfeeeea9_b4baa304_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -48,
            mantissa: 0x8e109265_a66393e8_a33646c5_85d0ba16_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -44,
            mantissa: 0xa9671293_1a0d6041_51cc9bc0_ad2461df_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -40,
            mantissa: 0xb061afcc_6f4d05d2_b926d5d9_b47c0172_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -36,
            mantissa: 0xa039d17c_4d55483a_2b39d90e_d8e03de3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -33,
            mantissa: 0xfd92ae02_a0366717_bd1331a2_19b3916c_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -29,
            mantissa: 0xae5bfdae_50bb66d4_2ac34bea_4ba9b128_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -26,
            mantissa: 0xcfa58c78_a4167a6e_97ae7616_f0553da3_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -23,
            mantissa: 0xd52793cf_74ac26bd_d5800287_97bb5656_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -20,
            mantissa: 0xbb737ea1_59a1ab1b_203d09f3_53293bfc_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -17,
            mantissa: 0x8c172597_97519909_d450bc5e_f7346a1a_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -15,
            mantissa: 0xb01241b7_f476dded_68756bd7_93311623_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -13,
            mantissa: 0xb77a8654_a8c8cfb6_86fbd12f_20aa21c6_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -11,
            mantissa: 0x9b85f327_836de71e_0a95c587_df73dd47_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xd0c72b4a_81123937_16778b17_feaab3f7_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -9,
            mantissa: 0xd54b34b5_08f7c7a1_53a5d591_64f5be90_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -8,
            mantissa: 0x9b9b8af7_85bf3bf1_7158ff4f_6d389faa_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Neg,
            exponent: -8,
            mantissa: 0x90351b61_b023a397_22d92dce_f0326527_u128,
        },
        DyadicFloat128 {
            sign: DyadicSign::Pos,
            exponent: -10,
            mantissa: 0xfeb8c9fd_06312e7b_7e5a02a3_0147801d_u128,
        },
    ];

    let recip = DyadicFloat128::accurate_reciprocal(x);

    let z = f_polyeval39(
        recip, P[0], P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10], P[11], P[12],
        P[13], P[14], P[15], P[16], P[17], P[18], P[19], P[20], P[21], P[22], P[23], P[24], P[25],
        P[26], P[27], P[28], P[29], P[30], P[31], P[32], P[33], P[34], P[35], P[36], P[37], P[38],
    );
    let r_sqrt = bessel_rsqrt_hard(x, recip);
    let f_exp = rational128_exp(x);
    (z * r_sqrt * f_exp).fast_as_f64()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_i0() {
        assert!(f_i0(f64::NAN).is_nan());
        assert_eq!(f_i0(f64::INFINITY), f64::INFINITY);
        assert_eq!(f_i0(f64::NEG_INFINITY), f64::INFINITY);
        assert_eq!(f_i0(715.), f64::INFINITY);
        assert_eq!(f_i0(12.), 18948.925349296307);
        assert_eq!(f_i0(16.), 893446.227920105);
        assert_eq!(f_i0(18.432), 9463892.87209841);
        assert_eq!(f_i0(26.432), 23507752424.350075);
        assert_eq!(f_i0(0.2), 1.010025027795146);
        assert_eq!(f_i0(7.5), 268.16131151518937);
        assert_eq!(f_i0(-1.5), 1.646723189772891);
    }
}
