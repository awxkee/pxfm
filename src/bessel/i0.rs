/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::common::f_fmla;
use crate::double_double::DoubleDouble;
use crate::exponents::{EXP_REDUCE_T0, EXP_REDUCE_T1};
use crate::polyeval::{f_polyeval13, f_polyeval30};

/// Modified bessel of the first kind of order 0
///
/// Max ULP 0.5003
pub fn f_i0(x: f64) -> f64 {
    let xb = x.to_bits() & 0x7fff_ffff_ffff_ffff;

    if !x.is_normal() {
        if x == 0. {
            return 1.;
        }
        if x.is_infinite() {
            return f64::INFINITY;
        }
        if x.is_nan() {
            return f64::NAN;
        }
    }

    if xb > 0x40864fe5304e83e4u64 {
        // 713.9869085439682
        return f64::INFINITY;
    }

    if xb <= 0x401e000000000000u64 {
        return i0_0_to_7p5(f64::from_bits(xb));
    } else if xb <= 0x4023000000000000u64 {
        // 9.5
        return i0f_7p5_to_9p5(f64::from_bits(xb));
    }

    i0_asympt(f64::from_bits(xb))
}

/**
Computes I0 on interval [-7.5; 7.5]
as rational approximation I0 = 1 + (x/2)^2 * Pn((x/2)^2)/Qm((x/2)^2))
where n = 16 and m = 0.

Relative error on interval 2^-(105.71).

Generated by SageMath:
```python
from sage.all import *
from mpmath import mp, besseli, taylor

mp.prec = 450

def shifted_i0(x):
    return besseli(0, x) - mp.mpf(1)

terms = 100
from mpmath import taylor
coeffs = taylor(shifted_i0, 0, terms)

R = PolynomialRing(RealField(450), 'y')
y = R.gen()
f = R(0)

for n in range(2, terms, 2):
    k = n // 2
    c = RealField(450)(coeffs[n])
    if n >= 1:
        f += R(c) * y**(k-1) * (4**k)
    else:
        f += R(c) * y**(k-1) * (4**k)

# See the series
print(f)
```
See ./notes/bessel_i0.ipynb for generation

Next step is poly generation in Sollya see ./notes/bessel_sollya/bessel_i0_small.sollya for generation

Poly relative error: 2^(-113.068)
**/
#[inline]
fn i0_0_to_7p5(x: f64) -> f64 {
    let dx = x;
    const ONE_OVER_4: f64 = 1. / 4.;
    let eval_x = DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_mult(dx, dx), ONE_OVER_4);
    const C_HI: [u64; 13] = [
        0x3cc69ca9cf3b7f54,
        0x3c54197a7f5154ac,
        0x3bde725594ee5635,
        0x3b63e22d70eef5f3,
        0x3ae69f7da85a3684,
        0x3a669f7da7587231,
        0x39e40a2dd7510be5,
        0x395faaf027a436b0,
        0x38d6751eb6db3f82,
        0x384cbbaa0ee5961e,
        0x37c0c6617d78c8a2,
        0x3730bc7067cf1d2b,
        0x36a6d1ecab8941e9,
    ];

    let r = f_polyeval13(
        eval_x.to_f64(),
        f64::from_bits(C_HI[0]),
        f64::from_bits(C_HI[1]),
        f64::from_bits(C_HI[2]),
        f64::from_bits(C_HI[3]),
        f64::from_bits(C_HI[4]),
        f64::from_bits(C_HI[5]),
        f64::from_bits(C_HI[6]),
        f64::from_bits(C_HI[7]),
        f64::from_bits(C_HI[8]),
        f64::from_bits(C_HI[9]),
        f64::from_bits(C_HI[10]),
        f64::from_bits(C_HI[11]),
        f64::from_bits(C_HI[12]),
    );

    const C: [(u64, u64); 10] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0xb920000000000000, 0x3fd0000000000000),
        (0x3c3c71c71c71c7a9, 0x3f9c71c71c71c71c),
        (0x3bfc71c71c71957f, 0x3f5c71c71c71c71c),
        (0x3b5234567ac59180, 0x3f123456789abcdf),
        (0xbb4b6edec79ebb6c, 0x3ec02e85c0898b71),
        (0xbb0604da86fe5358, 0x3e6522a43f65486a),
        (0xbaa604f353c368eb, 0x3e0522a43f65486a),
        (0xba487ed3becfe5cf, 0x3da0b313289be0b9),
        (0xb9af8b40c7d3b838, 0x3d35601885e63e5d),
    ];

    let mut p = DoubleDouble::mul_f64_add(eval_x, r, DoubleDouble::from_bit_pair(C[9]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[8]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[7]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[6]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[5]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[4]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[3]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[2]));
    p = DoubleDouble::mul_add(eval_x, p, DoubleDouble::from_bit_pair(C[1]));
    p = DoubleDouble::mul_add_f64(eval_x, p, f64::from_bits(C[0].1));

    let z = DoubleDouble::quick_mult(p, eval_x);

    DoubleDouble::full_add_f64(z, 1.).to_f64()
}

/**
Mid-interval [7.5;9.5] generated by Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/9.5, 1/7.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya
**/
#[inline]
fn i0f_7p5_to_9p5(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_recip(x);
    let z = f_polyeval30(
        recip,
        DoubleDouble::from_bit_pair((0x3c44ae0a81a58637, 0x3fd9881c5b9bafec)),
        DoubleDouble::from_bit_pair((0xbc158a6b63dc8af9, 0x3faac1fb162436ca)),
        DoubleDouble::from_bit_pair((0x3c3aebf3e28b8c95, 0xbfd04dae24f51f9d)),
        DoubleDouble::from_bit_pair((0xbcaa2a59a27e11f9, 0x403568c8fba2199d)),
        DoubleDouble::from_bit_pair((0xbd394ffa78b8a5b7, 0xc09225af61795385)),
        DoubleDouble::from_bit_pair((0x3d70c9c70bb76c23, 0x40e79152e7fa2751)),
        DoubleDouble::from_bit_pair((0xbdbc115588be01a3, 0xc138569583c89da1)),
        DoubleDouble::from_bit_pair((0xbe213053d35a908c, 0x41848383b28fc248)),
        DoubleDouble::from_bit_pair((0xbe5130de9bcca0d1, 0xc1ccbf1445575859)),
        DoubleDouble::from_bit_pair((0x3ebaf84a7d3b89c8, 0x4210f7fdc1a50923)),
        DoubleDouble::from_bit_pair((0x3ed03871420ddb40, 0xc2510b9440d14c2c)),
        DoubleDouble::from_bit_pair((0x3efa6b2431be80d2, 0x428d5a54ab9e440d)),
        DoubleDouble::from_bit_pair((0xbf35e74181dbd249, 0xc2c5c823c66610fe)),
        DoubleDouble::from_bit_pair((0x3f69f2d1b6225347, 0x42fbf7fd8608902f)),
        DoubleDouble::from_bit_pair((0x3fcd423410b6c65e, 0xc32f26408db53d52)),
        DoubleDouble::from_bit_pair((0x3ff168cc3ec817af, 0x435e2102a8ceaf38)),
        DoubleDouble::from_bit_pair((0x40247cde607d8353, 0xc3894fa5b42b4153)),
        DoubleDouble::from_bit_pair((0x4055e52a5af7f70c, 0x43b27283f63ea2d4)),
        DoubleDouble::from_bit_pair((0x4071992ce8e3e252, 0xc3d7452bcc2bc149)),
        DoubleDouble::from_bit_pair((0x4079748416f2c4e3, 0x43f94d1eb6217d4e)),
        DoubleDouble::from_bit_pair((0xc0b1d14504809360, 0xc417930172f74ac4)),
        DoubleDouble::from_bit_pair((0xc0d0a6bb0781a075, 0x4432ac1f8da88117)),
        DoubleDouble::from_bit_pair((0xc0e4f963c6208e13, 0xc448df5abc8610f5)),
        DoubleDouble::from_bit_pair((0xc0d878d45eeda143, 0x445b7328a866305e)),
        DoubleDouble::from_bit_pair((0xc0f3b1b945b2556d, 0xc46897f32678bf64)),
        DoubleDouble::from_bit_pair((0x411a7c14045a0333, 0x4471615a27c20e76)),
        DoubleDouble::from_bit_pair((0x411986310b671c57, 0xc47290fde46108b2)),
        DoubleDouble::from_bit_pair((0xc100f4efb583ba56, 0x446bff9a0735e3c3)),
        DoubleDouble::from_bit_pair((0xc0eab922d08f1fdb, 0xc45a4d154b5765c3)),
        DoubleDouble::from_bit_pair((0x40daac42df9f1543, 0x4436c5f4f53ab38e)),
    );
    let e = i0_exp(dx);
    let r_sqrt = DoubleDouble::from_rsqrt(dx);
    DoubleDouble::quick_mult(z * r_sqrt, e).to_f64()
}

#[inline(always)]
fn exp_poly(z: f64) -> DoubleDouble {
    /* The following is a degree-6 polynomial generated by Sollya for exp(x)
    over [-2^-12.905,2^-12.905]
    with absolute error < 2^-108.634 (see sollya/bessel_i0_exp.sollya). */
    const Q: [(u64, u64); 7] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3a20e40000000000, 0x3ff0000000000000),
        (0x3a04820000000000, 0x3fe0000000000000),
        (0x3c6537b87598eb35, 0x3fc5555555555555),
        (0x3c453e1164955528, 0x3fa5555555555555),
        (0xbc236e26aec872a7, 0x3f8111111144fbef),
        (0xbbd53d924ae90c8c, 0x3f56c16c16ffeecc),
    ];
    let mut p = DoubleDouble::quick_mult_f64(DoubleDouble::from_bit_pair(Q[6]), z);
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[5]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[4]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[3]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[2]));
    p = DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[1]));
    DoubleDouble::mul_f64_add(p, z, DoubleDouble::from_bit_pair(Q[0]))
}

#[inline]
pub(crate) fn i0_exp(r: f64) -> DoubleDouble {
    const INVLOG2: f64 = f64::from_bits(0x40b71547652b82fe);

    let k = (r * INVLOG2).round();

    const L2: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0x3d0718432a1b0e26),
        f64::from_bits(0x3f262e42ff000000),
    );

    let zh = f_fmla(L2.lo, k, f_fmla(-L2.hi, k, r));

    let bk = k as i64;
    let mk = (bk >> 12) + 0x3ff;
    let i2 = (bk >> 6) & 0x3f;
    let i1 = bk & 0x3f;

    let t0 = DoubleDouble::from_bit_pair(EXP_REDUCE_T0[i2 as usize]);
    let t1 = DoubleDouble::from_bit_pair(EXP_REDUCE_T1[i1 as usize]);
    let mut de = DoubleDouble::quick_mult(t1, t0);
    let q = exp_poly(zh);
    de = DoubleDouble::quick_mult(de, q);

    let mut du = (mk as u64).wrapping_shl(52);
    du = f64::from_bits(du).to_bits();
    DoubleDouble::quick_mult_f64(de, f64::from_bits(du))
}

/**
Generated in Sollya:
```text
pretty = proc(u) {
  return ~(floor(u*1000)/1000);
};

bessel_i0_approximant = library("./cmake-build-release/libbessel_sollya.dylib");

prec = 1000;

f = bessel_i0_approximant(1/x);
d = [1/709.3, 1/9.5];
w = 1;
pf = remez(f, 29, d, 1, 1e-40);

for i from 0 to degree(pf) do {
    print("'", coeff(pf, i), "',");
};
```
See ./notes/bessel_sollya
**/
#[inline]
fn i0_asympt(x: f64) -> f64 {
    let dx = x;
    let recip = DoubleDouble::from_recip(x);
    let z = f_polyeval30(
        recip,
        DoubleDouble::from_bit_pair((0xbc7c1377032a0a64, 0x3fd9884533d43651)),
        DoubleDouble::from_bit_pair((0xbc45e47ff971096d, 0x3fa9884533d43587)),
        DoubleDouble::from_bit_pair((0x3c34fc7cc8b988f9, 0x3f9cb94dda552f2b)),
        DoubleDouble::from_bit_pair((0x3c36e54b0dd085b7, 0x3f9debb109b61dc9)),
        DoubleDouble::from_bit_pair((0x3c41e6868f4d5917, 0x3fa6e87ee54a8972)),
        DoubleDouble::from_bit_pair((0x3c3989a41a24145c, 0x3fb72bdb6c41cbbd)),
        DoubleDouble::from_bit_pair((0x3c4aad4c46560cd4, 0x3fcf799a83545bed)),
        DoubleDouble::from_bit_pair((0xbc82e815160a2300, 0xbffdff58df7716df)),
        DoubleDouble::from_bit_pair((0x3ce520ae923832b0, 0x40724ffcc87d2082)),
        DoubleDouble::from_bit_pair((0xbd75b73448c9c752, 0xc0d961e4d922e0d1)),
        DoubleDouble::from_bit_pair((0xbdb0cf0f1ea7bc63, 0x413c7d324261577c)),
        DoubleDouble::from_bit_pair((0x3e3901959e0aa1a1, 0xc199fa44d7ec023b)),
        DoubleDouble::from_bit_pair((0x3e93422362429a42, 0x41f372843e5aaa6e)),
        DoubleDouble::from_bit_pair((0x3eb3a84ccf581408, 0xc24817811300fb90)),
        DoubleDouble::from_bit_pair((0x3f3b1e6094a03a23, 0x4298d719a784b4de)),
        DoubleDouble::from_bit_pair((0x3f2bfaa33420d672, 0xc2e567ed0056e1d6)),
        DoubleDouble::from_bit_pair((0x3fcfb61f1b1d875c, 0x432eea4c5a7430b4)),
        DoubleDouble::from_bit_pair((0xc01e6689f1e0d774, 0xc372ba656951ac2e)),
        DoubleDouble::from_bit_pair((0x4050ce0115c626f7, 0x43b3072820882e2e)),
        DoubleDouble::from_bit_pair((0xc099dc6f5e058416, 0xc3f02e1c0674446f)),
        DoubleDouble::from_bit_pair((0x40a12887892585ea, 0x4426f1a3d0faf34c)),
        DoubleDouble::from_bit_pair((0x40f337dd37031f59, 0xc45af84ecdbce892)),
        DoubleDouble::from_bit_pair((0x412aaa80ab5e7dd6, 0x448a0e9fa4493dae)),
        DoubleDouble::from_bit_pair((0xc1425899c2a4bb3a, 0xc4b471a56a81cc70)),
        DoubleDouble::from_bit_pair((0xc15ad42ecaac864f, 0x44d99ba476302220)),
        DoubleDouble::from_bit_pair((0xc195c38e309c4549, 0xc4f8f9c0970973a8)),
        DoubleDouble::from_bit_pair((0x4197ec13566e7076, 0x4512439547684b69)),
        DoubleDouble::from_bit_pair((0x41b14b88b32a34fb, 0xc522d4bba3771a58)),
        DoubleDouble::from_bit_pair((0xc1bc7e986417022d, 0x4528661e01397b58)),
        DoubleDouble::from_bit_pair((0x41b431a9bac39ee8, 0xc51dded7dbe00d0a)),
    );

    let e = i0_exp(dx * 0.5);
    let r_sqrt = DoubleDouble::from_rsqrt(dx);
    DoubleDouble::quick_mult(z * r_sqrt * e, e).to_f64()
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_i0() {
        assert!(f_i0(f64::NAN).is_nan());
        assert_eq!(f_i0(f64::INFINITY), f64::INFINITY);
        assert_eq!(f_i0(f64::NEG_INFINITY), f64::INFINITY);
        assert_eq!(f_i0(715.), f64::INFINITY);
        assert_eq!(f_i0(12.), 18948.925349296307);
        assert_eq!(f_i0(16.), 893446.227920105);
        assert_eq!(f_i0(18.432), 9463892.87209841);
        assert_eq!(f_i0(26.432), 23507752424.350075);
        assert_eq!(f_i0(0.2), 1.010025027795146);
        assert_eq!(f_i0(7.5), 268.16131151518937);
        assert_eq!(f_i0(-1.5), 1.646723189772891);
    }
}
