/*
 * // Copyright (c) Radzivon Bartoshyk 7/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::bessel::j1::{j1_asympt_alpha, j1_asympt_beta};
use crate::bessel::y0::log_dd;
use crate::bessel::y1_coeffs::Y1_COEFFS;
use crate::bessel::y1f_coeffs::{Y1_ZEROS, Y1_ZEROS_VALUES};
use crate::double_double::DoubleDouble;
use crate::polyeval::{f_polyeval15, f_polyeval35};
use crate::sin_helper::cos_dd_small;
use crate::sincos_reduce::{AngleReduced, rem2pi_any};

/// Bessel of the second kind order one ( Y1 )
///
/// Max found ULP 0.500001
pub fn f_y1(x: f64) -> f64 {
    if x < 0. {
        return f64::NAN;
    }

    if !x.is_normal() {
        if x == 0. {
            return f64::NEG_INFINITY;
        }

        if x.is_nan() {
            return x + x;
        }

        if x.is_infinite() {
            if x.is_sign_negative() {
                return f64::NAN;
            }
            return 0.;
        }
    }

    if x <= 1.4 {
        return y1_near_zero(x);
    }

    if x <= 51.5 {
        return y1_small_argument_path(x);
    }

    // Exceptions
    let xb = x.to_bits();
    if xb == 0x571a31ffe2ff7e9fu64 {
        return f64::from_bits(0x32e58532f95056ffu64);
    }

    y1_asympt(x)
}

/**
Generated by SageMath:
Evaluates:
y2 = -J1(x)*log(x) + 1/x * (1 - sum((-1)^m*(H(m)+H(m-1))/(2^m*m!*(m-1)!)*x^(2*m))
Y1(x) = 2/pi*(-y2(x)+(euler_gamma - log(2))*J1(x))
expressed as:
Y1(x)=log(x)*W1(x) - Z1(x) - 2/(pi*x)
```python
from sage.all import *

R = LaurentSeriesRing(RealField(300), 'x', default_prec=300)
x = R.gen()
N = 16  # Number of terms (adjust as needed)
gamma = RealField(300)(euler_gamma)
d2 = RealField(300)(2)
pi = RealField(300).pi()
log2 = RealField(300)(2).log()

def j_series(n, x):
    return sum([(-1)**m * (x/2)**(ZZ(n) + ZZ(2)*ZZ(m)) / (ZZ(m).factorial() * (ZZ(m) + ZZ(n)).factorial()) for m in range(N)])

J1_series = j_series(1, x)

def harmony(m):
    return sum(RealField(300)(1)/RealField(300)(k) for k in range(1, m+1))

def z_series(x):
    return sum([(-1)**m * (x)**(ZZ(2)*ZZ(m)) / (ZZ(2)**(2*m) * ZZ(m).factorial() * (ZZ(m) - ZZ(1)).factorial()) * (harmony(m) + harmony(m - 1)) for m in range(1, N)])

W1 = d2/pi * J1_series
Z1 = -(d2/(x*pi) * z_series(x) + d2/pi * gamma * J1_series(x) - d2/pi * log2 * J1_series(x))

def y1_full(x):
    return d2/pi * (J1_series(x) * x.log() - 1/x * ( 1 - z_series(x)) + (gamma - log2) * J1_series(x))

# see the series
print(W0)
print(Z0)
```
See ./notes/bessel_y1_taylor.ipynb for generation
**/
fn y1_near_zero(x: f64) -> f64 {
    const W: [(u64, u64); 15] = [
        (0xbc76b01ec5417056, 0x3fd45f306dc9c883),
        (0x3c46b01ec5417056, 0xbfa45f306dc9c883),
        (0xbbfe40290701eb1e, 0x3f5b2995e7b7b604),
        (0xbba67fe4a5feb897, 0xbf021bb945252402),
        (0xbb0334914cdd2ba9, 0x3e9cf9286ea1d337),
        (0x3aab4f3c6d42c1f4, 0xbe2ee7a29824147f),
        (0xba407fb57ef4dc2c, 0x3db78be9987d036d),
        (0x39d2921e91b07dd0, 0xbd3ae90af76a4d0f),
        (0x395a28c8620dc90e, 0x3cb7eb97f85e7d62),
        (0xb8cf83f52abe45c5, 0xbc31028e3376648a),
        (0xb8441050c68ca435, 0x3ba3cb1e7d0c17e7),
        (0xb7ab072548a1aa43, 0xbb133191ed9f1eef),
        (0xb6f05192c2d9b6ee, 0x3a7f7f4b5e8ef7b0),
        (0x367ad65afe306d57, 0xb9e626e36cb3515d),
        (0xb5ea1c4136f8f230, 0x394b01153dce6810),
    ];
    let x2 = DoubleDouble::from_exact_mult(x, x);
    let mut w = f_polyeval15(
        x2,
        DoubleDouble::from_bit_pair(W[0]),
        DoubleDouble::from_bit_pair(W[1]),
        DoubleDouble::from_bit_pair(W[2]),
        DoubleDouble::from_bit_pair(W[3]),
        DoubleDouble::from_bit_pair(W[4]),
        DoubleDouble::from_bit_pair(W[5]),
        DoubleDouble::from_bit_pair(W[6]),
        DoubleDouble::from_bit_pair(W[7]),
        DoubleDouble::from_bit_pair(W[8]),
        DoubleDouble::from_bit_pair(W[9]),
        DoubleDouble::from_bit_pair(W[10]),
        DoubleDouble::from_bit_pair(W[11]),
        DoubleDouble::from_bit_pair(W[12]),
        DoubleDouble::from_bit_pair(W[13]),
        DoubleDouble::from_bit_pair(W[14]),
    );
    w = DoubleDouble::quick_mult_f64(w, x);

    const Z: [(u64, u64); 15] = [
        (0x3c61d7eb2e54cda1, 0x3fc91866143cbc8a),
        (0xbc2f9f7a0ce54a40, 0xbfabd3975c75b4a7),
        (0xbbf7659313f45e8c, 0x3f6835b97894be5b),
        (0x3b9cbcd40f1be7b9, 0xbf12c7dbffcde97d),
        (0xbb495d78778645b4, 0x3eb0a780ac776eac),
        (0xbae15be86455c1ab, 0xbe432e5a4ddeea30),
        (0xba5ad966c12f1e3c, 0x3dcf0ce34d2066a6),
        (0x39e9717155dc7521, 0xbd52a4e1aea45c18),
        (0x394f447fe5de1290, 0x3cd1474ade9154ac),
        (0xb8e1699d9009a7fc, 0xbc4978ba84f218c0),
        (0xb8505502096ead17, 0x3bbe9598c016378b),
        (0x37942b6c36b2c5f1, 0xbb2e7e5fcfc4b7b1),
        (0x37210853b78bd08a, 0x3a99a6c1266c116d),
        (0xb686c9639c9d976e, 0xba02738998fe7337),
        (0xb603b739ee04b9fe, 0x3966f58cd41b6d08),
    ];
    let mut z = f_polyeval15(
        x2,
        DoubleDouble::from_bit_pair(Z[0]),
        DoubleDouble::from_bit_pair(Z[1]),
        DoubleDouble::from_bit_pair(Z[2]),
        DoubleDouble::from_bit_pair(Z[3]),
        DoubleDouble::from_bit_pair(Z[4]),
        DoubleDouble::from_bit_pair(Z[5]),
        DoubleDouble::from_bit_pair(Z[6]),
        DoubleDouble::from_bit_pair(Z[7]),
        DoubleDouble::from_bit_pair(Z[8]),
        DoubleDouble::from_bit_pair(Z[9]),
        DoubleDouble::from_bit_pair(Z[10]),
        DoubleDouble::from_bit_pair(Z[11]),
        DoubleDouble::from_bit_pair(Z[12]),
        DoubleDouble::from_bit_pair(Z[13]),
        DoubleDouble::from_bit_pair(Z[14]),
    );
    z = DoubleDouble::quick_mult_f64(z, x);
    let w_log = log_dd(x);

    const MINUS_TWO_OVER_PI: DoubleDouble =
        DoubleDouble::from_bit_pair((0x3c86b01ec5417056, 0xbfe45f306dc9c883));

    let m_two_over_pi_div_x = DoubleDouble::div_dd_f64(MINUS_TWO_OVER_PI, x);
    if m_two_over_pi_div_x.hi.is_infinite() {
        return f64::NEG_INFINITY;
    }

    let zvp = DoubleDouble::mul_add(w, w_log, -z);
    DoubleDouble::dd_add(m_two_over_pi_div_x, zvp).to_f64()
}

/// This method on small range searches for nearest zero or extremum.
/// Then picks stored series expansion at the point end evaluates the poly at the point.
pub(crate) fn y1_small_argument_path(x: f64) -> f64 {
    let x_abs = x;

    // let avg_step = 51.03 / 33.0;
    // let inv_step = 1.0 / avg_step;
    //
    // println!("inv_step {}", inv_step);

    const INV_STEP: f64 = 0.6466784244562023;

    let fx = x_abs * INV_STEP;
    const Y1_ZEROS_COUNT: f64 = (Y1_ZEROS.len() - 1) as f64;
    let idx0 = fx.min(Y1_ZEROS_COUNT) as usize;
    let idx1 = fx.ceil().min(Y1_ZEROS_COUNT) as usize;

    let found_zero0 = DoubleDouble::from_bit_pair(Y1_ZEROS[idx0]);
    let found_zero1 = DoubleDouble::from_bit_pair(Y1_ZEROS[idx1]);

    let dist0 = (found_zero0.hi - x_abs).abs();
    let dist1 = (found_zero1.hi - x_abs).abs();

    let (found_zero, idx, dist) = if dist0 < dist1 {
        (found_zero0, idx0, dist0)
    } else {
        (found_zero1, idx1, dist1)
    };

    if idx == 0 {
        return y1_near_zero(x);
    }

    let j1c = &Y1_COEFFS[idx - 1];
    let c0 = j1c;

    let r = DoubleDouble::full_add_f64(DoubleDouble::new(-found_zero.lo, -found_zero.hi), x_abs);

    // We hit exact zero, value, better to return it directly
    if dist == 0. {
        return f64::from_bits(Y1_ZEROS_VALUES[idx]);
    }

    let c = &c0[15..];

    let p0 = f_polyeval35(
        r.to_f64(),
        f64::from_bits(c[0].1),
        f64::from_bits(c[1].1),
        f64::from_bits(c[2].1),
        f64::from_bits(c[3].1),
        f64::from_bits(c[4].1),
        f64::from_bits(c[5].1),
        f64::from_bits(c[6].1),
        f64::from_bits(c[7].1),
        f64::from_bits(c[8].1),
        f64::from_bits(c[9].1),
        f64::from_bits(c[10].1),
        f64::from_bits(c[11].1),
        f64::from_bits(c[12].1),
        f64::from_bits(c[13].1),
        f64::from_bits(c[14].1),
        f64::from_bits(c[15].1),
        f64::from_bits(c[16].1),
        f64::from_bits(c[17].1),
        f64::from_bits(c[18].1),
        f64::from_bits(c[19].1),
        f64::from_bits(c[20].1),
        f64::from_bits(c[21].1),
        f64::from_bits(c[22].1),
        f64::from_bits(c[23].1),
        f64::from_bits(c[24].1),
        f64::from_bits(c[25].1),
        f64::from_bits(c[26].1),
        f64::from_bits(c[27].1),
        f64::from_bits(c[28].1),
        f64::from_bits(c[29].1),
        f64::from_bits(c[30].1),
        f64::from_bits(c[31].1),
        f64::from_bits(c[32].1),
        f64::from_bits(c[33].1),
        f64::from_bits(c[34].1),
    );

    let c = c0;

    let mut p_e = DoubleDouble::mul_f64_add(r, p0, DoubleDouble::from_bit_pair(c[14]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[13]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[12]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[11]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[10]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[9]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[8]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[7]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[6]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[5]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[4]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[3]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[2]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[1]));
    p_e = DoubleDouble::mul_add(p_e, r, DoubleDouble::from_bit_pair(c[0]));

    p_e.to_f64()
}

/*
   Evaluates:
   Y1 = sqrt(2/(PI*x)) * beta(x) * sin(x - 3*PI/4 - alpha(x))

   Discarding 1/2*PI gives:
   Y1 = sqrt(2/(PI*x)) * beta(x) * (-cos(x - PI/4 - alpha(x)))
*/
pub(crate) fn y1_asympt(x: f64) -> f64 {
    const SQRT_2_OVER_PI: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0xbc8cbc0d30ebfd15),
        f64::from_bits(0x3fe9884533d43651),
    );
    const MPI_OVER_4: DoubleDouble = DoubleDouble::new(
        f64::from_bits(0xbc81a62633145c07),
        f64::from_bits(0xbfe921fb54442d18),
    );

    let recip = if x.to_bits() > 0x7fd000000000000u64 {
        DoubleDouble::quick_mult_f64(DoubleDouble::from_exact_safe_div(4.0, x), 0.25)
    } else {
        DoubleDouble::from_recip(x)
    };

    let alpha = j1_asympt_alpha(recip);
    let beta = j1_asympt_beta(recip);

    let AngleReduced { angle } = rem2pi_any(x);

    // Without full subtraction cancellation happens sometimes
    let x0pi34 = DoubleDouble::dd_sub(MPI_OVER_4, alpha);
    let r0 = DoubleDouble::dd_add(angle, x0pi34);

    let m_cos = -cos_dd_small(r0);
    let z0 = DoubleDouble::quick_mult(beta, m_cos);
    let r_sqrt = DoubleDouble::from_rsqrt(x);
    let scale = DoubleDouble::quick_mult(SQRT_2_OVER_PI, r_sqrt);
    let p = DoubleDouble::quick_mult(scale, z0);
    let norm = DoubleDouble::from_full_exact_add(p.hi, p.lo);
    norm.to_f64()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_y1() {
        assert_eq!(
            f_y1(f64::from_bits(0x400193bed4dff243)),
            0.00000000000000002513306678922122
        );
        assert_eq!(
            f_y1(f64::from_bits(0x3ffc513c569fe78e)),
            -0.24189760895998239
        );
        assert_eq!(
            f_y1(f64::from_bits(0x4192391e4c8faa60)),
            -0.000000000000000002572292246748134
        );
        assert_eq!(
            f_y1(f64::from_bits(0x403e9e480605283c)),
            -0.00000000000000001524456280251315
        );
        assert_eq!(
            f_y1(f64::from_bits(0x40277f9138d43206)),
            0.000000000000000006849807120770496
        );
        assert_eq!(f_y1(f64::INFINITY), 0.);
        assert!(f_y1(f64::NEG_INFINITY).is_nan());
        assert!(f_y1(f64::NAN).is_nan());
    }
}
