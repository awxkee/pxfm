/*
 * // Copyright (c) Radzivon Bartoshyk 8/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::common::f_fmla;
use crate::double_double::DoubleDouble;
use crate::logs::fast_log_dd;
use crate::polyeval::{
    f_polyeval4, f_polyeval5, f_polyeval6, f_polyeval7, f_polyeval8, f_polyeval9, f_polyeval10,
};

#[cold]
fn inverf_0p06_to_0p375(x: f64, z: f64, z2: DoubleDouble) -> f64 {
    // Polynomial for inverf(x) = x * R(x^2)
    // Generated by Wolfram Mathematica
    // <<FunctionApproximations`
    // ClearAll["Global`*"]
    // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
    // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.06,0.75/2},8,8},WorkingPrecision->70]
    // num=Numerator[approx][[1]];
    // den=Denominator[approx][[1]];
    // poly=num;
    // coeffs=CoefficientList[poly,z];
    // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
    const C_NUM: [(u64, u64); 9] = [
        (0xbc8618e37222f619, 0x3fec5bf891b4ef6b),
        (0x3cacf60d19f1c45d, 0xc00cf8c806368978),
        (0x3cb9381f20ae6bcf, 0x4018364ca5a4eaed),
        (0xbcaf40f6a3735a9d, 0xc01542980f72ddb2),
        (0x3ca14a77b270643e, 0x4004ee1d94bbb2ac),
        (0x3c51f4c5ae597dfb, 0xbfe6bff271ad1a2c),
        (0xbc5795fb7cb3cdbf, 0x3fb8e1705b73d805),
        (0x3c1f749bfb404050, 0xbf759450409506eb),
        (0xbba24236f9f48fec, 0x3f0b46d25d15aa67),
    ];
    let mut p_num = DoubleDouble::mul_add(
        z2,
        DoubleDouble::from_bit_pair(C_NUM[8]),
        DoubleDouble::from_bit_pair(C_NUM[7]),
    );
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[6]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[5]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[4]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[3]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[2]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[1]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[0]));

    const C_DEN: [(u64, u64); 9] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0x3cb1d232049cdb1c, 0xc011648da86e3654),
        (0x3cbf830a4db06e68, 0x401f4c52522c3fbc),
        (0x3c85300f0d439b12, 0xc01e12130ae88e17),
        (0x3cb8f1d1a4e30ed8, 0x401094e93a983bb9),
        (0xbc8648b98ba4f825, 0xbff4f2c0bad8b068),
        (0x3c6aaddd07b3f393, 0x3fcc67fcd5eedbd0),
        (0x3c077691ab1ece87, 0xbf918a616f323471),
        (0x3bd356d67fa0052f, 0x3f39920730ba03f5),
    ];
    let mut p_den = DoubleDouble::mul_add(
        z2,
        DoubleDouble::from_bit_pair(C_DEN[8]),
        DoubleDouble::from_bit_pair(C_DEN[7]),
    );
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[6]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[5]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[4]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[3]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[2]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[1]));
    p_den = DoubleDouble::mul_add_f64(z2, p_den, f64::from_bits(0x3ff0000000000000));
    let p_prod = DoubleDouble::div(p_num, p_den);
    let p = DoubleDouble::quick_mult_f64(p_prod, z);
    f64::copysign(p.to_f64(), x)
}

#[cold]
fn inverf_0p375_to_0p42(x: f64, z: f64, z2: DoubleDouble) -> f64 {
    // Polynomial for inverf(x) = x * R(x^2)
    // Generated by Wolfram Mathematica
    // <<FunctionApproximations`
    // ClearAll["Global`*"]
    // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
    // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.75/2,0.42},9,9},WorkingPrecision->70]
    // num=Numerator[approx][[1]];
    // den=Denominator[approx][[1]];
    // poly=den;
    // coeffs=CoefficientList[poly,z];
    // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
    const C_NUM: [(u64, u64); 10] = [
        (0xbc80cfc0ec1cac5a, 0x3fec5bf891b4ef6b),
        (0x3cad10a4a55b71fb, 0xc01163122052733c),
        (0xbcc0dcd539f0b568, 0x402200364234231b),
        (0xbccc94b2e5d5c958, 0xc0246d1b78c95ed0),
        (0x3c9b6171e7712901, 0x401b9192f712d9b3),
        (0x3c9d806ccdda5727, 0xc0066e7bb9cfbccf),
        (0xbbfe28f08ce5732c, 0x3fe5395bdf8588a0),
        (0xbc5e29d39486ecec, 0xbfb51c3820ef619a),
        (0xbbf2492c7872fd43, 0x3f71679ec43873da),
        (0x3bad5eee652eb4ce, 0xbf061f6f8186e9fd),
    ];
    let mut p_num = DoubleDouble::mul_add(
        z2,
        DoubleDouble::from_bit_pair(C_NUM[9]),
        DoubleDouble::from_bit_pair(C_NUM[8]),
    );
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[7]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[6]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[5]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[4]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[3]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[2]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[1]));
    p_num = DoubleDouble::mul_add(z2, p_num, DoubleDouble::from_bit_pair(C_NUM[0]));

    const C_DEN: [(u64, u64); 10] = [
        (0x0000000000000000, 0x3ff0000000000000),
        (0xbcb359b719b646a1, 0xc014aa9401152a5d),
        (0x3ca659a6fd51c68e, 0x4026baa701e0e472),
        (0xbccd348367f7a47f, 0xc02bb4ff84d68fa0),
        (0x3ca6114bf66321d4, 0x4024661540a49fe7),
        (0xbc8d031d8beac7b0, 0xc01284d4ae192941),
        (0x3c878a068630bcb7, 0x3ff44029f83bc8c8),
        (0xbc4f2599b5ff8d2a, 0xbfc8c42d44e678ff),
        (0x3c1e7d62d404659b, 0x3f8cb1639933dde5),
        (0xbb90897a717691f5, 0xbf3486f64e3e0778),
    ];
    let mut p_den = DoubleDouble::mul_add(
        z2,
        DoubleDouble::from_bit_pair(C_DEN[9]),
        DoubleDouble::from_bit_pair(C_DEN[8]),
    );
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[7]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[6]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[5]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[4]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[3]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[2]));
    p_den = DoubleDouble::mul_add(z2, p_den, DoubleDouble::from_bit_pair(C_DEN[1]));
    p_den = DoubleDouble::mul_add_f64(z2, p_den, f64::from_bits(0x3ff0000000000000));
    let p_prod = DoubleDouble::div(p_num, p_den);
    let p = DoubleDouble::quick_mult_f64(p_prod, z);
    f64::copysign(p.to_f64(), x)
}

/// Inverse error function
///
/// Max ulp 0.7
pub fn f_erfinv(x: f64) -> f64 {
    let ax = x.to_bits() & 0x7fff_ffff_ffff_ffff;
    if ax >= 0x3ff0000000000000u64 {
        // |x| > 1
        if ax == 0x3ff0000000000000u64 {
            return if x.is_sign_negative() {
                f64::NEG_INFINITY
            } else {
                f64::INFINITY
            };
        }
        return f64::NAN;
    }
    if ax == 0 {
        return 0.;
    }

    let z = f64::from_bits(ax);

    if ax <= 0x3f8374bc6a7ef9db {
        // 0.0095
        // for small |x| using taylor series first 3 terms
        // Generated by SageMath:
        // from mpmath import mp, erf
        //
        // mp.prec = 100
        //
        // def inverf_series(n_terms):
        //     from mpmath import taylor
        //     series_erf = taylor(mp.erfinv, 0, n_terms)
        //     return series_erf
        //
        // ser = inverf_series(10)
        // for i in range(1, len(ser), 2):
        //     k = ser[i]
        //     print("f64::from_bits(" + double_to_hex(RealField(100)(k)) + "),")
        let z2 = DoubleDouble::from_exact_mult(z, z);
        let p = f_fmla(
            z2.hi,
            f64::from_bits(0x3fb62847c47dda48),
            f64::from_bits(0x3fc053c2c0ab91c5),
        );
        let mut r = DoubleDouble::mul_f64_add(
            z2,
            p,
            DoubleDouble::from_bit_pair((0xbc33ea2ef8dde075, 0x3fcdb29fb2fee5e4)),
        );
        r = DoubleDouble::mul_add(
            z2,
            r,
            DoubleDouble::from_bit_pair((0xbc8618f13eb7ca89, 0x3fec5bf891b4ef6b)),
        );
        // (rh + rl) * z = rh * z + rl*z
        let v = DoubleDouble::quick_mult_f64(r, z);
        return f64::copysign(v.to_f64(), x);
    } else if ax <= 0x3faeb851eb851eb8 {
        // 0.06
        // for |x| < 0.06 using taylor series first 5 terms
        // Generated by SageMath:
        // from mpmath import mp, erf
        //
        // mp.prec = 100
        //
        // def inverf_series(n_terms):
        //     from mpmath import taylor
        //     series_erf = taylor(mp.erfinv, 0, n_terms)
        //     return series_erf
        //
        // ser = inverf_series(10)
        // for i in range(1, len(ser), 2):
        //     k = ser[i]
        //     print("f64::from_bits(" + double_to_hex(RealField(100)(k)) + "),")
        let z2 = DoubleDouble::from_exact_mult(z, z);
        let p = f_polyeval4(
            z2.hi,
            f64::from_bits(0x3fb62847c47dda48),
            f64::from_bits(0x3fb0a13189c6ef7a),
            f64::from_bits(0x3faa7c85c89bb08b),
            f64::from_bits(0x3fa5eeb1d488e312),
        );
        let mut r = DoubleDouble::mul_f64_add(
            z2,
            p,
            DoubleDouble::from_bit_pair((0x3c2cec68daff0d80, 0x3fc053c2c0ab91c5)),
        );
        r = DoubleDouble::mul_add(
            z2,
            r,
            DoubleDouble::from_bit_pair((0xbc33ea2ef8dde075, 0x3fcdb29fb2fee5e4)),
        );
        r = DoubleDouble::mul_add(
            z2,
            r,
            DoubleDouble::from_bit_pair((0xbc8618f13eb7ca89, 0x3fec5bf891b4ef6b)),
        );
        // (rh + rl) * z = rh * z + rl*z
        let v = DoubleDouble::quick_mult_f64(r, z);
        return f64::copysign(v.to_f64(), x);
    }

    if ax <= 0x3fd8000000000000u64 {
        // |x| <= 0.375

        // Polynomial for inverf(x) = x * R(x^2)
        // Generated by Wolfram Mathematica:
        // <<FunctionApproximations`
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
        // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.06,0.75/2},8,8},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=num;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let z2 = DoubleDouble::from_exact_mult(z, z);
        let pf_num = f_polyeval7(
            z2.hi,
            f64::from_bits(0x4018364ca5a4eaed),
            f64::from_bits(0xc01542980f72ddb2),
            f64::from_bits(0x4004ee1d94bbb2ac),
            f64::from_bits(0xbfe6bff271ad1a2c),
            f64::from_bits(0x3fb8e1705b73d805),
            f64::from_bits(0xbf759450409506eb),
            f64::from_bits(0x3f0b46d25d15aa67),
        );
        let mut p_num = DoubleDouble::mul_f64_add(
            z2,
            pf_num,
            DoubleDouble::from_bit_pair((0x3cacf60d19f1c45d, 0xc00cf8c806368978)),
        );
        p_num = DoubleDouble::mul_add(
            z2,
            p_num,
            DoubleDouble::from_bit_pair((0xbc8618e37222f619, 0x3fec5bf891b4ef6b)),
        );
        let pf_den = f_polyeval7(
            z2.hi,
            f64::from_bits(0x401f4c52522c3fbc),
            f64::from_bits(0xc01e12130ae88e17),
            f64::from_bits(0x401094e93a983bb9),
            f64::from_bits(0xbff4f2c0bad8b068),
            f64::from_bits(0x3fcc67fcd5eedbd0),
            f64::from_bits(0xbf918a616f323471),
            f64::from_bits(0x3f39920730ba03f5),
        );
        let mut p_den = DoubleDouble::mul_f64_add(
            z2,
            pf_den,
            DoubleDouble::from_bit_pair((0x3cb1d232049cdb1c, 0xc011648da86e3654)),
        );
        p_den = DoubleDouble::mul_add_f64(z2, p_den, f64::from_bits(0x3ff0000000000000));
        let p_prod = DoubleDouble::div(p_num, p_den);
        let p = DoubleDouble::quick_mult_f64(p_prod, z);
        let err = f_fmla(
            z2.hi,
            f64::from_bits(0x3c80000000000000), // 2^-55
            f64::from_bits(0x3ba0000000000000), // 2^-69
        );
        let ub = p.hi + (p.lo + err);
        let lb = p.hi + (p.lo - err);
        if ub == lb {
            return f64::copysign(p.to_f64(), x);
        }
        return inverf_0p06_to_0p375(x, z, z2);
    } else if z <= 0.42 {
        // |x| <= 0.42
        // Polynomial for inverf(x) = x * R(x^2)
        // Generated by Wolfram Mathematica:
        // <<FunctionApproximations`
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
        // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.75/2,0.42},9,9},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=num;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let z2 = DoubleDouble::from_exact_mult(z, z);
        let pf_num = f_polyeval5(
            z2.hi,
            f64::from_bits(0xc0066e7bb9cfbccf),
            f64::from_bits(0x3fe5395bdf8588a0),
            f64::from_bits(0xbfb51c3820ef619a),
            f64::from_bits(0x3f71679ec43873da),
            f64::from_bits(0xbf061f6f8186e9fd),
        );
        let mut p_num = DoubleDouble::mul_f64_add(
            z2,
            pf_num,
            DoubleDouble::from_bit_pair((0x3c9b6171e7712901, 0x401b9192f712d9b3)),
        );
        p_num = DoubleDouble::mul_add(
            z2,
            p_num,
            DoubleDouble::from_bit_pair((0xbccc94b2e5d5c958, 0xc0246d1b78c95ed0)),
        );
        p_num = DoubleDouble::mul_add(
            z2,
            p_num,
            DoubleDouble::from_bit_pair((0xbcc0dcd539f0b568, 0x402200364234231b)),
        );
        p_num = DoubleDouble::mul_add(
            z2,
            p_num,
            DoubleDouble::from_bit_pair((0x3cad10a4a55b71fb, 0xc01163122052733c)),
        );
        p_num = DoubleDouble::mul_add(
            z2,
            p_num,
            DoubleDouble::from_bit_pair((0xbc80cfc0ec1cac5a, 0x3fec5bf891b4ef6b)),
        );
        let pf_den = f_polyeval6(
            z2.hi,
            f64::from_bits(0x4024661540a49fe7),
            f64::from_bits(0xc01284d4ae192941),
            f64::from_bits(0x3ff44029f83bc8c8),
            f64::from_bits(0xbfc8c42d44e678ff),
            f64::from_bits(0x3f8cb1639933dde5),
            f64::from_bits(0xbf3486f64e3e0778),
        );
        let mut p_den = DoubleDouble::mul_f64_add(
            z2,
            pf_den,
            DoubleDouble::from_bit_pair((0xbccd348367f7a47f, 0xc02bb4ff84d68fa0)),
        );
        p_den = DoubleDouble::quick_mul_add(
            z2,
            p_den,
            DoubleDouble::from_bit_pair((0x3ca659a6fd51c68e, 0x4026baa701e0e472)),
        );
        p_den = DoubleDouble::quick_mul_add(
            z2,
            p_den,
            DoubleDouble::from_bit_pair((0xbcb359b719b646a1, 0xc014aa9401152a5d)),
        );
        p_den = DoubleDouble::mul_add_f64(z2, p_den, f64::from_bits(0x3ff0000000000000));
        let p_prod = DoubleDouble::div(p_num, p_den);
        let p = DoubleDouble::quick_mult_f64(p_prod, z);
        let err = f_fmla(
            z2.hi,
            f64::from_bits(0x3c70000000000000), // 2^-56
            f64::from_bits(0x3bc0000000000000), // 2^-67
        );
        let ub = p.hi + (p.lo + err);
        let lb = p.hi + (p.lo - err);
        if ub == lb {
            return f64::copysign(p.to_f64(), x);
        }
        return inverf_0p375_to_0p42(x, z, z2);
    }

    let q = DoubleDouble::from_full_exact_add(1.0, -z);

    //TODO: this is part from boost, don't have good ideas how to approximate this part reasonable fast and accurate
    if z <= 0.5 {
        const Y: f64 = 0.0891314744949340820313;
        let g = DoubleDouble::quick_mult_f64(DoubleDouble::from_full_exact_add(z, 10.0), z);

        const P: [f64; 8] = [
            -0.000508781949658280665617,
            -0.00836874819741736770379,
            0.0334806625409744615033,
            -0.0126926147662974029034,
            -0.0365637971411762664006,
            0.0219878681111168899165,
            0.00822687874676915743155,
            -0.00538772965071242932965,
        ];

        const Q: [f64; 10] = [
            1.0,
            -0.970005043303290640362,
            -1.56574558234175846809,
            1.56221558398423026363,
            0.662328840472002992063,
            -0.71228902341542847553,
            -0.0527396382340099713954,
            0.0795283687341571680018,
            -0.00233393759374190016776,
            0.000886216390456424707504,
        ];

        let p_num_s = f_polyeval7(z, P[1], P[2], P[3], P[4], P[5], P[6], P[7]);
        let p_num = DoubleDouble::f64_mul_f64_add_f64(z, p_num_s, P[0]);

        let p_den_s = f_polyeval9(z, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6], Q[7], Q[8], Q[9]);
        let p_den = DoubleDouble::f64_mul_f64_add_f64(z, p_den_s, Q[0]);

        let r = DoubleDouble::div(p_num, p_den);
        let k0 = DoubleDouble::quick_mult(r, g);
        let p = DoubleDouble::mul_f64_add(g, Y, k0);
        return f64::copysign(p.to_f64(), x);
    } else if z <= 0.75 {
        const Y: f64 = 2.249481201171875;
        let g = DoubleDouble::quick_mult_f64(fast_log_dd(q), -2.0).fast_sqrt();
        let xs = DoubleDouble::full_add_f64(q, -0.25);

        const P: [f64; 9] = [
            -0.202433508355938759655,
            0.105264680699391713268,
            8.37050328343119927838,
            17.6447298408374015486,
            -18.8510648058714251895,
            -44.6382324441786960818,
            17.445385985570866523,
            21.1294655448340526258,
            -3.67192254707729348546,
        ];
        let p_num_s = f_polyeval8(xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8]);
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 9] = [
            1.0,
            6.24264124854247537712,
            3.9713437953343869095,
            -28.6608180499800029974,
            -20.1432634680485188801,
            48.5609213108739935468,
            10.8268667355460159008,
            -22.6436933413139721736,
            1.72114765761200282724,
        ];
        let p_den_s = f_polyeval8(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6], Q[7], Q[8]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);
        let z_den = DoubleDouble::full_add_f64(r, Y);
        let p = DoubleDouble::div(g, z_den);
        return f64::copysign(p.to_f64(), x);
    }

    let mut zeta = fast_log_dd(q);
    zeta = DoubleDouble::from_exact_add(zeta.hi, zeta.lo);
    zeta = -zeta;
    let zeta_sqrt = zeta.fast_sqrt();
    if zeta_sqrt.hi < 3.0 {
        const Y: f64 = 0.807220458984375;
        let xs = DoubleDouble::full_add_f64(zeta_sqrt, -1.125);

        const P: [f64; 11] = [
            -0.131102781679951906451,
            -0.163794047193317060787,
            0.117030156341995252019,
            0.387079738972604337464,
            0.337785538912035898924,
            0.142869534408157156766,
            0.0290157910005329060432,
            0.00214558995388805277169,
            -0.679465575181126350155e-6,
            0.285225331782217055858e-7,
            -0.681149956853776992068e-9,
        ];

        let p_num_s = f_polyeval10(
            xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8], P[9], P[10],
        );
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 8] = [
            1.0,
            3.46625407242567245975,
            5.38168345707006855425,
            4.77846592945843778382,
            2.59301921623620271374,
            0.848854343457902036425,
            0.152264338295331783612,
            0.01105924229346489121,
        ];

        let p_den_s = f_polyeval7(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6], Q[7]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);

        let r0 = DoubleDouble::quick_mult(r, zeta_sqrt);
        let p = DoubleDouble::mul_f64_add(zeta_sqrt, Y, r0);
        f64::copysign(p.to_f64(), x)
    } else if zeta_sqrt.hi < 6.0 {
        const Y: f64 = 0.93995571136474609375;
        let xs = DoubleDouble::full_add_f64(zeta_sqrt, -3.0);

        const P: [f64; 9] = [
            -0.0350353787183177984712,
            -0.00222426529213447927281,
            0.0185573306514231072324,
            0.00950804701325919603619,
            0.00187123492819559223345,
            0.000157544617424960554631,
            0.460469890584317994083e-5,
            -0.230404776911882601748e-9,
            0.266339227425782031962e-11,
        ];

        let p_num_s = f_polyeval8(xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8]);
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 7] = [
            1.0,
            1.3653349817554063097,
            0.762059164553623404043,
            0.220091105764131249824,
            0.0341589143670947727934,
            0.00263861676657015992959,
            0.764675292302794483503e-4,
        ];

        let p_den_s = f_polyeval6(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);

        let r0 = DoubleDouble::quick_mult(r, zeta_sqrt);
        let p = DoubleDouble::mul_f64_add(zeta_sqrt, Y, r0);
        f64::copysign(p.to_f64(), x)
    } else if zeta_sqrt.hi < 18.0 {
        const Y: f64 = 0.98362827301025390625;
        let xs = DoubleDouble::full_add_f64(zeta_sqrt, -6.0);

        const P: [f64; 9] = [
            -0.0167431005076633737133,
            -0.00112951438745580278863,
            0.00105628862152492910091,
            0.000209386317487588078668,
            0.149624783758342370182e-4,
            0.449696789927706453732e-6,
            0.462596163522878599135e-8,
            -0.281128735628831791805e-13,
            0.99055709973310326855e-16,
        ];

        let p_num_s = f_polyeval8(xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7], P[8]);
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 7] = [
            1.0,
            0.591429344886417493481,
            0.138151865749083321638,
            0.0160746087093676504695,
            0.000964011807005165528527,
            0.275335474764726041141e-4,
            0.282243172016108031869e-6,
        ];

        let p_den_s = f_polyeval6(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);

        let r0 = DoubleDouble::quick_mult(r, zeta_sqrt);
        let p = DoubleDouble::mul_f64_add(zeta_sqrt, Y, r0);
        f64::copysign(p.to_f64(), x)
    } else if zeta_sqrt.hi < 44.0 {
        const Y: f64 = 0.99714565277099609375;
        let xs = DoubleDouble::full_add_f64(zeta_sqrt, -18.0);

        const P: [f64; 8] = [
            -0.0024978212791898131227,
            -0.779190719229053954292e-5,
            0.254723037413027451751e-4,
            0.162397777342510920873e-5,
            0.396341011304801168516e-7,
            0.411632831190944208473e-9,
            0.145596286718675035587e-11,
            -0.116765012397184275695e-17,
        ];

        let p_num_s = f_polyeval7(xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7]);
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 7] = [
            1.0,
            0.207123112214422517181,
            0.0169410838120975906478,
            0.000690538265622684595676,
            0.145007359818232637924e-4,
            0.144437756628144157666e-6,
            0.509761276599778486139e-9,
        ];

        let p_den_s = f_polyeval6(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);

        let r0 = DoubleDouble::quick_mult(r, zeta_sqrt);
        let p = DoubleDouble::mul_f64_add(zeta_sqrt, Y, r0);
        f64::copysign(p.to_f64(), x)
    } else {
        const Y: f64 = 0.99941349029541015625;
        let xs = DoubleDouble::full_add_f64(zeta_sqrt, -44.0);

        const P: [f64; 8] = [
            -0.000539042911019078575891,
            -0.28398759004727721098e-6,
            0.899465114892291446442e-6,
            0.229345859265920864296e-7,
            0.225561444863500149219e-9,
            0.947846627503022684216e-12,
            0.135880130108924861008e-14,
            -0.348890393399948882918e-21,
        ];

        let p_num_s = f_polyeval7(xs.hi, P[1], P[2], P[3], P[4], P[5], P[6], P[7]);
        let p_num = DoubleDouble::mul_f64_add_f64(xs, p_num_s, P[0]);

        const Q: [f64; 7] = [
            1.0,
            0.0845746234001899436914,
            0.00282092984726264681981,
            0.468292921940894236786e-4,
            0.399968812193862100054e-6,
            0.161809290887904476097e-8,
            0.231558608310259605225e-11,
        ];

        let p_den_s = f_polyeval6(xs.hi, Q[1], Q[2], Q[3], Q[4], Q[5], Q[6]);
        let p_den = DoubleDouble::mul_f64_add_f64(xs, p_den_s, Q[0]);
        let r = DoubleDouble::div(p_num, p_den);

        let r0 = DoubleDouble::quick_mult(r, zeta_sqrt);
        let p = DoubleDouble::mul_f64_add(zeta_sqrt, Y, r0);
        f64::copysign(p.to_f64(), x)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_erfinv() {
        assert_eq!(f_erfinv(0.001000000000084706), 0.0008862271575416209);
        assert_eq!(f_erfinv(-0.001000000000084706), -0.0008862271575416209);
        assert_eq!(f_erfinv(0.71), 0.7482049711849852);
        assert_eq!(f_erfinv(-0.71), -0.7482049711849852);
        assert_eq!(f_erfinv(0.41), 0.381014610957532);
        assert_eq!(f_erfinv(-0.41), -0.381014610957532);
        assert_eq!(f_erfinv(0.32), 0.29165547581744206);
        assert_eq!(f_erfinv(-0.32), -0.29165547581744206);
        assert_eq!(f_erfinv(0.82), 0.9480569762323499);
        assert_eq!(f_erfinv(-0.82), -0.9480569762323499);
        assert_eq!(f_erfinv(0.05), 0.044340387910005497);
        assert_eq!(f_erfinv(-0.05), -0.044340387910005497);
        assert_eq!(f_erfinv(0.99), 1.8213863677184494);
        assert_eq!(f_erfinv(-0.99), -1.8213863677184494);
        assert_eq!(f_erfinv(0.9900000000867389), 1.821386369839293);
        assert_eq!(f_erfinv(0.99999), 3.123413274341571);
        assert!(f_erfinv(f64::NEG_INFINITY).is_nan());
        assert!(f_erfinv(f64::INFINITY).is_nan());
        assert!(f_erfinv(f64::NAN).is_nan());
    }
}
