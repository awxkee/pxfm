/*
 * // Copyright (c) Radzivon Bartoshyk 8/2025. All rights reserved.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // 1.  Redistributions of source code must retain the above copyright notice, this
 * // list of conditions and the following disclaimer.
 * //
 * // 2.  Redistributions in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // 3.  Neither the name of the copyright holder nor the names of its
 * // contributors may be used to endorse or promote products derived from
 * // this software without specific prior written permission.
 * //
 * // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * // DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * // FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * // DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * // SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * // CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
use crate::logs::simple_fast_log;
use crate::polyeval::{f_polyeval3, f_polyeval5, f_polyeval8, f_polyeval10, f_polyeval12};

/// Inverse error function
///
/// Max ulp 0.5
pub fn f_erfinvf(x: f32) -> f32 {
    let ax = x.to_bits() & 0x7fff_ffff;
    if ax >= 0x3f800000 {
        // |x| > 1
        if ax == 0x3f800000 {
            return if x.is_sign_negative() {
                f32::NEG_INFINITY
            } else {
                f32::INFINITY
            };
        }
        return f32::NAN;
    }
    if ax == 0 {
        return 0.;
    }

    let z = f32::from_bits(ax) as f64;

    if ax <= 0x3c1ba5e3u32 {
        // 0.0095
        // for small |x| using taylor series first 3 terms
        let z2 = z * z;
        // Generated by SageMath:
        // from mpmath import mp, erf
        //
        // mp.prec = 100
        //
        // def inverf_series(n_terms):
        //     from mpmath import taylor
        //     series_erf = taylor(mp.erfinv, 0, n_terms)
        //     return series_erf
        //
        // ser = inverf_series(10)
        // for i in range(1, len(ser), 2):
        //     k = ser[i]
        //     print("f64::from_bits(" + double_to_hex(RealField(100)(k)) + "),")
        let p = f_polyeval3(
            z2,
            f64::from_bits(0x3fec5bf891b4ef6b),
            f64::from_bits(0x3fcdb29fb2fee5e4),
            f64::from_bits(0x3fc053c2c0ab91c5),
        ) * z;
        return f32::copysign(p as f32, x);
    } else if ax <= 0x3d75c28fu32 {
        // 0.06
        // for |x| < 0.06 using taylor series first 5 terms
        let z2 = z * z;
        // Generated by SageMath:
        // from mpmath import mp, erf
        //
        // mp.prec = 100
        //
        // def inverf_series(n_terms):
        //     from mpmath import taylor
        //     series_erf = taylor(mp.erfinv, 0, n_terms)
        //     return series_erf
        //
        // ser = inverf_series(10)
        // for i in range(1, len(ser), 2):
        //     k = ser[i]
        //     print("f64::from_bits(" + double_to_hex(RealField(100)(k)) + "),")
        let p = f_polyeval5(
            z2,
            f64::from_bits(0x3fec5bf891b4ef6b),
            f64::from_bits(0x3fcdb29fb2fee5e4),
            f64::from_bits(0x3fc053c2c0ab91c5),
            f64::from_bits(0x3fb62847c47dda48),
            f64::from_bits(0x3fb0a13189c6ef7a),
        ) * z;
        return f32::copysign(p as f32, x);
    }

    if ax <= 0x3f400000u32 {
        // |x| <= 0.75
        let z2 = z * z;

        // Generated by Wolfram Mathematica:
        // <<FunctionApproximations`
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
        // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.06,0.75},7,7},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=num;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let p_num = f_polyeval8(
            z2,
            f64::from_bits(0x3fec5bf891b4f08b),
            f64::from_bits(0xc00c1f1d775c1702),
            f64::from_bits(0x40166df2b12a26e5),
            f64::from_bits(0xc0124bac84bf9289),
            f64::from_bits(0x3ffff4966807d0f2),
            f64::from_bits(0xbfdc3ca349746fe8),
            f64::from_bits(0x3fa49cfd81dd1494),
            f64::from_bits(0xbf4843a8ea9f279c),
        );
        let p_den = f_polyeval8(
            z2,
            f64::from_bits(0x3ff0000000000000),
            f64::from_bits(0xc010e9bf92356539),
            f64::from_bits(0x401d293be013b475),
            f64::from_bits(0xc01a3c2c4fbdf360),
            f64::from_bits(0x400a169d8f5dc386),
            f64::from_bits(0xbfebc6b28eaf7743),
            f64::from_bits(0x3fbba3a2f7d3817e),
            f64::from_bits(0xbf714ae0fab8f3b6),
        );
        let k = (p_num / p_den) * z;
        f32::copysign(k as f32, x)
    } else if ax <= 0x3f580000u32 {
        // |x| <= 0.84375
        let z2 = z * z;

        // Generated by Wolfram Mathematica:
        // <<FunctionApproximations`
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Sqrt[x]]/Sqrt[x]
        // {err0,approx}=MiniMaxApproximation[f[z],{z,{0.75,0.75+(0.9375-0.75)/2},9,9},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=num;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let p_num = f_polyeval10(
            z2,
            f64::from_bits(0x3fec5bf898cd5e2a),
            f64::from_bits(0xc015bbd6b5534ac7),
            f64::from_bits(0x402cc450d45bd6c9),
            f64::from_bits(0xc03571caa9369494),
            f64::from_bits(0x4033abcf60a3f441),
            f64::from_bits(0xc026ba17a9b49c63),
            f64::from_bits(0x4010305063348ae3),
            f64::from_bits(0xbfea6182ae9ebe9e),
            f64::from_bits(0x3fb4730b3b8bb3b2),
            f64::from_bits(0xbf60ce54a2d8a789),
        );
        let p_den = f_polyeval10(
            z2,
            f64::from_bits(0x3ff0000000000000),
            f64::from_bits(0xc0199233b621fa1d),
            f64::from_bits(0x4031c2789bbcd54d),
            f64::from_bits(0xc03c0647230bdc27),
            f64::from_bits(0x403b8733e87f6a75),
            f64::from_bits(0xc03151d92fca8b86),
            f64::from_bits(0x401b9861498016b4),
            f64::from_bits(0xbffa581e4c63e1b0),
            f64::from_bits(0x3fca710be72a1024),
            f64::from_bits(0xbf83be49c2d5cb9e),
        );
        let k = (p_num / p_den) * z;
        f32::copysign(k as f32, x)
    } else if ax <= 0x3f700000u32 {
        // |x| <= 0.9375
        // Rational approximation generated by Wolfram Mathematica:
        // for inverf(x) = sqrt(-log(1-x))*R(1/sqrt(-log(1-x)))
        //
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Exp[-1/(x^2)]*(-1+Exp[1/(x^2)])]/(Sqrt[-Log[1-(Exp[-1/(x^2)]*(-1+Exp[1/(x^2)]))]] )
        // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.75+(0.9375-0.75)/2,0.9375},9,9},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=den;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let zeta = -simple_fast_log(1. - z);
        let zeta_sqrt = zeta.sqrt();
        let rcp_zeta = (1. / zeta) * zeta_sqrt;
        let p_num = f_polyeval10(
            rcp_zeta,
            f64::from_bits(0x3ff0009ee1eb9fb7),
            f64::from_bits(0x4031454f73317efa),
            f64::from_bits(0x40538da74145bfd0),
            f64::from_bits(0x406282be1ffe5bfa),
            f64::from_bits(0x4067c8913eea4440),
            f64::from_bits(0x4065d0cb13140731),
            f64::from_bits(0x405cc8e119d645c8),
            f64::from_bits(0x404a1e304fafaf2a),
            f64::from_bits(0x402e25e784e51507),
            f64::from_bits(0xbf064cbce6f10834),
        );
        let p_den = f_polyeval10(
            rcp_zeta,
            f64::from_bits(0x3ff0000000000000),
            f64::from_bits(0x403148e85483c1f6),
            f64::from_bits(0x405418953a681a98),
            f64::from_bits(0x406565f3995a4426),
            f64::from_bits(0x40700ea39c206495),
            f64::from_bits(0x40713d7db7ff5155),
            f64::from_bits(0x406c54a856da4a0f),
            f64::from_bits(0x40614bc323b2a330),
            f64::from_bits(0x404d79c1dab1bdde),
            f64::from_bits(0x4031021c98b116e4),
        );
        let r = zeta_sqrt * (p_num / p_den);
        f32::copysign(r as f32, x)
    } else {
        // Rational approximation generated by Wolfram Mathematica:
        // for inverf(x) = sqrt(-log(1-x))*R(1/sqrt(-log(1-x)))
        //
        // <<FunctionApproximations`
        // ClearAll["Global`*"]
        // f[x_]:=InverseErf[Exp[-1/(x^2)]*(-1+Exp[1/(x^2)])]/(Sqrt[-Log[1-(Exp[-1/(x^2)]*(-1+Exp[1/(x^2)]))]] )
        // {err0, approx}=MiniMaxApproximation[f[z],{z,{0.9375,1-(10^(-14))},11,11},WorkingPrecision->70]
        // num=Numerator[approx][[1]];
        // den=Denominator[approx][[1]];
        // poly=num;
        // coeffs=CoefficientList[poly,z];
        // TableForm[Table[Row[{"'",NumberForm[coeffs[[i+1]],{50,50}, ExponentFunction->(Null&)],"',"}],{i,0,Length[coeffs]-1}]]
        let zeta = -simple_fast_log(1. - z);
        let zeta_sqrt = zeta.sqrt();
        let rcp_zeta = (1. / zeta) * zeta_sqrt;
        let p_num = f_polyeval12(
            rcp_zeta,
            f64::from_bits(0x3ff0007e1e866ba0),
            f64::from_bits(0x40331260344dd33e),
            f64::from_bits(0x40593ab0e07db78b),
            f64::from_bits(0x406f35270af12fd3),
            f64::from_bits(0x407a1d07db7556b0),
            f64::from_bits(0x40801b4db8d080ed),
            f64::from_bits(0x407e87801b3b2acd),
            f64::from_bits(0x407640e51485dd37),
            f64::from_bits(0x40691b2dff63f89d),
            f64::from_bits(0x4053675b18f1d6d7),
            f64::from_bits(0x40356749bb07cbde),
            f64::from_bits(0xbea1e888397bb680),
        );
        let p_den = f_polyeval12(
            rcp_zeta,
            f64::from_bits(0x3ff0000000000000),
            f64::from_bits(0x4033159f3de9ca79),
            f64::from_bits(0x4059c8a81c174cdd),
            f64::from_bits(0x407143cbc37ca47e),
            f64::from_bits(0x408009deefa289da),
            f64::from_bits(0x40862a9daa25e4ac),
            f64::from_bits(0x4087f7e8176d87f0),
            f64::from_bits(0x4084a1206fd336e6),
            f64::from_bits(0x407bd90c7a4f5f0c),
            f64::from_bits(0x406dd6a9410df4ce),
            f64::from_bits(0x4055e512f54c8e6f),
            f64::from_bits(0x403826b5d7a56257),
        );
        let r = zeta_sqrt * (p_num / p_den);
        f32::copysign(r as f32, x)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn f_test_inv_erff() {
        assert!(f_erfinvf(-1.1).is_nan());
        assert!(f_erfinvf(1.1).is_nan());
        assert!(f_erfinvf(f32::NEG_INFINITY).is_nan());
        assert!(f_erfinvf(f32::INFINITY).is_nan());
        assert_eq!(f_erfinvf(-1.), f32::NEG_INFINITY);
        assert_eq!(f_erfinvf(1.), f32::INFINITY);
        assert_eq!(f_erfinvf(0.002), 0.0017724558);
        assert_eq!(f_erfinvf(-0.002), -0.0017724558);
        assert_eq!(f_erfinvf(0.02), 0.017726395);
        assert_eq!(f_erfinvf(-0.02), -0.017726395);
        assert_eq!(f_erfinvf(0.05), 0.044340387);
        assert_eq!(f_erfinvf(-0.05), -0.044340387);
        assert_eq!(f_erfinvf(0.5), 0.47693628);
        assert_eq!(f_erfinvf(-0.5), -0.47693628);
        assert_eq!(f_erfinvf(0.76), 0.8308411);
        assert_eq!(f_erfinvf(-0.76), -0.8308411);
        assert_eq!(f_erfinvf(0.92), 1.2379221);
        assert_eq!(f_erfinvf(-0.92), -1.2379221);
        assert_eq!(f_erfinvf(0.97), 1.5344859);
        assert_eq!(f_erfinvf(-0.97), -1.5344859);
        assert_eq!(f_erfinvf(0.99), 1.8213866);
        assert_eq!(f_erfinvf(-0.99), -1.8213866);
    }
}
